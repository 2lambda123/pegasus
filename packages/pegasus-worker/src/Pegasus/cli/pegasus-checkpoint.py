#!/usr/bin/env python3
import argparse
import logging
import logging.handlers
import re
import subprocess
import sys
import tarfile
from typing import Callable, Iterable, List, Set

log = logging.getLogger()

# name of archived & compressed checkpoints
CHECKPOINT_FILENAME = "pegasus.checkpoint.tar.gz"

# default directory to look for if no patterns given
DEFAULT_CHECKPOINT_DIR = "pegasus-checkpoints"

# pegasus-transfer url file expected to be generated by pegasus-lite
PEGASUS_TRANSFER_URL_FILE = "pegasus_checkpoint_transfer_urls.json"


def parse_args(args: List[str] = sys.argv[1:]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Periodically transfer checkpoints back to staging site."
    )

    parser.add_argument(
        "-p",
        "--pattern",
        action="append",
        dest="patterns",
        help="""regex patterns to match when searching for files to checkpoint""",
    )

    def validate_interval(value: str) -> int:
        """
        Ensure that given interval is an integer and is nonzero.

        :param value: the given interval to validate
        :type value: str
        :raises argparse.ArgumentTypeError: interval cannot be casted to an int or is a negative integer
        :return: the given value
        :rtype: int
        """
        is_valid = True
        try:
            value = int(value)
        except ValueError:
            is_valid = False

        if not is_valid or value < 0:
            raise argparse.ArgumentTypeError(
                "interval {} must be a nonnegative integer".format(value)
            )

        return value

    parser.add_argument(
        "-i",
        "--interval",
        type=validate_interval,
        metavar="SECONDS",
        help="""interval in seconds at which pegasus-checkpoint will send
                checkpoint file back to the staging site
                """,
    )

    parser.add_argument(
        "-d", "--debug", action="store_true", default=False, help="enable debug logging"
    )

    parser.add_argument(
        "-l",
        "--log-to-file",
        action="store_true",
        default=False,
        help="enable logging to file pegasus-checkpoint.log",
    )

    return parser.parse_args(args)


def configure_logging(level: int, log_to_file: bool):
    """
    Setup logging.

    :param level: log level to use; set to :code:`logging.DEBUG` to enable debug logging
    :type level: int
    :param log_to_file: whether or not to write logs to the file pegasus-checkpoint.log
    :type log_to_file: bool
    """
    if level == logging.DEBUG:
        level = logging.DEBUG
    else:
        level = logging.INFO

    handlers = [logging.StreamHandler()]
    if log_to_file:
        handlers.append(
            logging.handlers.RotatingFileHandler(
                filename="pegasus-checkpoint.log",
                mode="a",
                maxBytes=(1 << 20),
                backupCount=2,
            )
        )

    logging.basicConfig(
        level=level, format="%(asctime)s [%(levelname)s] %(message)s", handlers=handlers
    )


def _get_matched_filenames(patterns: List[str]) -> Set[str]:
    """
    Get all files/folders in the current working directory that match the
    given file patterns.

    :param patterns: regex patterns to match filenames with
    :type patterns: List[str]
    :return: all files and or folders which match one of the given patterns
    :rtype: Set[str]
    """
    patterns = [re.compile(p) for p in patterns]
    files_in_cwd = [str(f) for f in Path(".").iterdir()]
    matched = Set()

    # n^2.. maybe can do a little better by pulling out files from files_in_cwd (using a set
    # isntead) as we make matches so we don't try to iterate over it again
    for p in patterns:
        for f in files_in_cwd:
            is_match = bool(p.fullmatch(f))

            if is_match:
                matched.add(f)

            log.debug("pattern: {}, file: {}, match: {}".format(p, f, is_match))

    log.info("given patterns matched the following filenames: {}".format(matched))

    return matched


def _archive_and_compress(filenames: Iterable[str]):
    """
    Given a list of file/folder names in CWD, archive and compress them into a single file
    :code:`pegasus.checkpoint.tar.gz`

    :param filenames: list of filenames to archive and compress 
    :type filenames: Iterable[str]
    """
    with tarfile.open(CHECKPOINT_FILENAME, "w|gz") as tar:
        for f in filenames:
            tar.add(name=f, recursive=True)

    checkpoint_size = Path(CHECKPOINT_FILENAME).stat().st_size

    log.info(
        "created {} byte checkpoint file: {}".format(
            checkpoint_size, CHECKPOINT_FILENAME
        )
    )


def _pegasus_transfer():
    """
    Invoke pegasus-transfer using the url file :code:`pegasus_checkpoint_transfer_urls.json`,
    generated by pegasus-lite.
    """
    cmd = ["pegasus-transfer", "-f", PEGASUS_TRANSFER_URL_FILE]
    log.debug("invoking {}".format(cmd))
    proc = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)

    log.info("pegasus-transfer logs:\n" + proc.stdout.decode())

    if proc.returncode != 0:
        log.error(
            "pegasus-transfer returned: {}, errors have occurred".format(
                proc.returncode
            )
        )


# TODO: what args will need to be passed here
# TODO: what will be provided by pegasus-lite
def _condor_chirp():
    pass


def run(patterns: List[str], xfer_func: Callable):
    """
    Gather files matching the given patterns. Archive and compress matching
    files. Send compressed checkpoint archive back to staging site using the
    given transfer function. 

    :param patterns: regex patterns to match with filenames
    :type patterns: List[str]
    :param xfer_func: file transfer tool to invoke (_pegasus_transfer or _condor_chirp)
    :type xfer_func: Callable
    """
    matched_filenames = _get_matched_filenames(patterns)
    _archive_and_compress(matched_filenames)
    xfer_func()


if __name__ == "__main__":
    args = parse_args()
    print(args)
    sys.exit(1)
    log_level = logging.INFO
    if args.debug:
        log_level = logging.DEBUG

    configure_logging(level=log_level, log_to_file=args.log_to_file)

    # TODO: determine which file transfer func to use and build up any args
    # to those functions if necessary

    if interval:
        # invoke run in infinite loop
        pass
    else:
        # invoke run once
        pass
