#!/usr/bin/env perl
#
# This file or a portion of this file is licensed under the terms of
# the Globus Toolkit Public License, found in file GTPL, or at
# http://www.globus.org/toolkit/download/license.html. This notice must
# appear in redistributions of this file, with or without modification.
#
# Redistributions of this Software, with or without modification, must
# reproduce the GTPL in: (1) the Software, or (2) the Documentation or
# some other similar material which is provided with the Software (if
# any).
#
# Copyright 1999-2004 University of Chicago and The University of
# Southern California. All rights reserved.
#
# Author  Gaurang Mehta gmehta@isi.edu
# Revision : $Revision$

require 5.006;
use strict;

use File::Basename; 		# standard module since 5.005
use File::Spec;			# standard module since 5.005 or 5.6.0
use Getopt::Long qw(:config bundling no_ignore_case);

# debug off
$main::debug = 0;
$_ = '$Revision$';      # don't edit, automatically updated by CVS
$main::revision=$1 if /Revision:\s+([0-9.]+)/o;



sub version() {
    my $version = `pegasus-version`;
    chomp($version);
    print "Pegasus $version, @{[basename($0)]} $main::revision\n";
    exit 0;
}


sub usage(;$) {
    my $msg = shift;
    print "ERROR: $msg\n" if defined $msg && lc($msg) ne 'help';

    print << "EOF";
Usage: @{[basename($0)]} [options]
 Pegasus_status helps monitor your jobs by querying condor. 
 -w|--workflow wf    The workflow to monitor.Default is all
 -t|--time t         The workflow planned time.
 -s|--site site     Montior jobs only on this site. Default is all sites
 -u|--user user      Monitor jobs for user x. Default is \$USER
 -j|--jobtype type  Monitor jobs of one of these types [compute, stagein, stageout, replica,cleanup,intersitetx,computestaged, createdir] . Default is all types.
 -v|--verbose   Enter verbose mode, default is not
 -V|--version   Print version number and exit.
EOF
    exit(1);
}

sub find_exec ($) {
    # purpose: determine location of a binary
    # paramtr: $program (IN): basename of the executable to look for
    # returns: fully qualified path to binary, undef if not found
    my $program = shift;
    local($_);
    foreach ( File::Spec->path ) {
        my $fs = File::Spec->catfile( $_, $program );
        return $fs if -x $fs;
    }
    undef;
}

sub exit_code ($$) {
    # purpose: check the exit code of a process
    # paramtr: $rc (IN): the raw exitcode
    #          $id (IN): some name to use in the generated messages
    # returns: undef: should not happen
    #          0: all is well
    #          1: non-zero exitcode
    #          2: died on signal
    my $rc = shift;
    my $id = shift;

    printf STDERR "# jobid=%s, exitcode=0x%04X\n", $id, $rc if $main::debug;
    if ( $rc == 0 ) {
	warn "$id finished successfully.\n" if $main::debug;
	return 0;
    } elsif ( ($rc >> 8) ) {
	print "$id exited with exitcode ", $rc>>8, "\n";
	return 1;
    } elsif ( ($rc & 127) > 0 ) {
	print "$id died on signal ", $rc & 127, "\n";
	return 2;
    }

    undef;
}
sub pipe_out_cmd {
    # purpose: Runs a cmd w/o invoking a shell, and captures stdout+stderr
    # warning: DO NOT use shell meta characters in the argument string.
    # paramtr: @arg (IN): argument string, executable first
    # returns: failed: undef
    #          scalar: first line of output
    #          vector: all lines of output
    local(*READ);               # must use type glob and local for FDs

    my $pid = open( READ, '-|' );
    return undef unless defined $pid;

    my @result;
    if ( $pid ) {
        # parent
        while ( <READ> ) {
            chomp;
            warn "# << $_\n" if $main::debug;
            push( @result, $_ );
        }
        close READ;
    } else {
        # child
        open( STDERR, '>&STDOUT');
        select(STDERR); $|=1;
        select(STDOUT); $|=1;
        exec { $_[0] } @_;      # lotsa magic :-)
        exit 127;               # no such exe :-(
    }

    wantarray ? @result : $result[0];
}

sub handler {
    # purpose: generic signal handler
    # paramtr: whatever the OS sends a signal handler and Perl makes of it
    # returns: dies
    my $sig = shift;
    # you should not do this in signal handler, but what the heck
    warn "# Signal $sig found\n" if $main::debug;
    die "ERROR: Killed by SIG$sig\n";
}

#
# --- main
#

$SIG{HUP} = \&handler;
$SIG{INT} = \&handler;
$SIG{TERM} = \&handler;
$SIG{QUIT} = \&handler;


my $workflow=undef;
my $time=undef;
my $site=undef;
my $jobtype=undef;
my $user=$ENV{'USER'};
my $notify=undef;
my $condor_q=find_exec('condor_q');

GetOptions( "workflow|w=s"    => \$workflow,
	    "time|t=s"   => \$time,
	    "user|u=s"  => \$user,
	    "sites|s=s" => \$site, 
	    "jobtype|j=s" => \$jobtype,
	    "notify|n=s" => \$notify,
	    "version|V" => \&version,
	    "verbose|v" => \$main::debug,
	    "help|h|?" => \&usage );

#  
# JOBTYPE to num mappings
my %jobtypes=("compute",1,
	      "stagein",2,
	      "stageout",3,
	      "replica",4,
	      "intersitetx",5,
	      "createdir",6,
	      "computestaged",7,
	      "cleanup",8);

my ($rc,$errors,@result);

my $arg1="-constraint";
my $args=undef;

## construct the command line string
my @arg=($condor_q);
push(@arg, '-constraint') if defined $workflow || defined $time || defined $site || defined $jobtype;
$args = "(pegasus_wf_name==\"$workflow\")" if defined $workflow;

if (defined $time) {
    $args.="$$" if defined $args;
    $args.= "(pegasus_wf_time==\"$time\")";
}
if (defined $site) {
    $args.="$$" if defined $args;
    $args.= "(pegasus_site==\"$site\")";
}

if (defined $jobtype) {
    $args.="$$" if defined $args;
    $args.= "(pegasus_job_class==$jobtypes{$jobtype})";
}

push(@arg,"$args") if defined $args;

push(@arg,$user);

warn "# Running @arg \n" if $main::debug;

## Run the command 
@result=pipe_out_cmd(@arg);

## Print the output result
 print "$_\n" foreach ( @result );

exit(exit_code($?,"condor_q"));
