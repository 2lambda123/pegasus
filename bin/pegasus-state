#!/usr/bin/env perl
#
# collect information about workflows and display their states.
#
##
#  Copyright 2007-2010 University Of Southern California
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing,
#  software distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
##
#
# Author: Jens-S. VÃ¶ckler voeckler at isi dot edu
# Revision: $Revision$
#
use 5.006;
use strict; 
use Carp; 
use Cwd qw(getcwd abs_path); 
use File::Spec;
use File::Basename qw(basename dirname); 
use Getopt::Long qw(:config bundling no_ignore_case);
use Data::Dumper; 

# path to load our libs..
BEGIN {
    require File::Spec->catfile( dirname($0), 'common.pm' );
    common->import(':all');
}
use Pegasus::Common;
use Pegasus::Properties qw(%initial); # parses -Dprop=val from @ARGV

if ( $^O eq 'darwin' ) { 
    # h2ph is broken on Darwin
    *TIOCGWINSZ = sub { 0x40087468; };
} else {
    eval { require "sys/ioctl.ph" }; 
}

#
# --- globals ----------------------------------------------
#
$main::debug = 0;		# debug output
$main::user = $ENV{USER} || $ENV{LOGNAME} || scalar getpwuid($>);
$_ = '$Revision$';     # don't edit, automatically updated by CVS
$main::revision=$1 if /Revision:\s+([0-9.]+)/o;
$main::onatty = -t STDOUT; 	# are we connected to a terminal?
$main::isutf8 = ( exists $ENV{LANG} && $ENV{LANG} =~ m{utf-?8}i ); 
$main::dirsep = File::Spec->catdir( '', '' ); 
@main::cstat = qw(U I R X C H);	# Condor job states (basic mode)
@main::color = 
    ( "\033[0;30m"		# unsubmitted (black)
    , "\033[0;34m"		# idle (blue)
    , "\033[0;32m"		# running (green)
    , "\033[0;35m"		# removing (magenta)
    , "\033[0;37m"		# completed (cyan)
    , "\033[0;31m"		# held (red)
    );
$main::bold  = "\033[1m"; 	# only works with black
$main::reset = "\033[0m";	# reset all color/bold/etc.
%main::color = map { $main::cstat[$_] => $main::color[$_] } 0 .. $#main::cstat;
%main::gstat = 			# Globus job states (expert mode)
    (   0 => '?'		# unknown
    ,   1 => 'P'                # pending
    ,   2 => 'A'                # active
    ,   4 => 'F'                # failed 
    ,   8 => 'D'                # done
    ,  16 => 'S'                # suspend
    ,  32 => 'U'                # unsuspend
    ,  64 => 'I'                # stage-in
    , 128 => 'O'                # stage-out
    );
%main::count = ();		# statistics keeper
$main::time = $^T;		# initialization only 
%main::dagman_p =		# predicate to determine variations on DAGMan
    map { $_ => 1 } qw(pegasus-dagman condor_dagman); 
%main::width = 			# width selection (0=unlimited)
    ( dagnodename => 24		# width of concrete dag node identifiers
    , pegasus_wf_name => 24	# width of abstract workflow identifiers
    , machine => 24		# width of hostnames
    , argument => 60            # width of arguments string
    );
$main::cache = undef;		# debug 
my ($rows,$cols) = &initialize_winch;

# %title describes any head we would want to show, indexed by a short internal key.
# {header} is what to put into the title of the output
# {function} is an fptr, being called with current row (q) job classads
# {width} is an initial width, with negative width meaning left adjustment
my %title =
    ( 'ST' => { header => 'ST'
	      , function => \&x_jobstatus
	      , width => -2
	      , legend => 'Condor job status'
              },
      'IN_STATE' => { header => 'IN_STATE'
		    , function => \&x_in_state
		    , width => 8
		    , legend => 'Time job spent in current Condor status'
                    },
      'JPRIO' => { header => 'PRI'
		 , width => 3
		 , function => \&x_jobpriority
		 , legend => 'Condor job priority'
	         },
      'JOB1' => { header => 'JOB'
	        , width => -50
	        , function => \&x_job1
		, legend => 'Workflow- or DAG-Node ID'
                },
      'JOB2' => { header => 'JOB'
	        , width => -32
	        , function => \&x_job2
		, legend => 'DAG-Node ID, command, and workflow-ID'
                },
      'CONDORID' => { header => 'ID'
		    , width => 2
		    , function => \&x_condorid
		    , legend => 'Condor cluster ID'
		    },
      'C/G' => { header => 'C/G'
	       , function => \&x_cgstatus
	       , width => 3
	       , legend => 'Condor- and Globus job status'
	       }
    );

# @title is an array, indexed by the 'expert level', of which columns to show
my @title = 
    ( 
       # first level is the novice state, leave out distractive information
       [qw(ST IN_STATE JOB1) ],
       # some more complex information in first expert level 
       [qw(C/G CONDORID IN_STATE JPRIO JOB2) ]
    );

#
# --- functions --------------------------------------------
#
sub usage(;$) {
    my $msg = shift;
    my $flag = defined $msg && lc($msg) ne 'help';
    if ( $flag ) {
	print "\033[1m" if $main::onatty;
	print "ERROR: $msg\n";
	print "\033[0m" if $main::onatty; 
    }

    my $app = basename($0); 
    print << "EOF";

Usage: $app [options ] [dagdir]
 $app helps monitor your jobs by querying Condor.

Optional arguments:
 -h|--help        print this help and exit.
 -V|--version     print version information and exit. 
 -v|--verbose     increase expert level.
 -d|--debug       increase debug level.
 -u|--user name   monitor for user 'name', default is $main::user.
 -w|--watch [s]   repeatedly print output every 's' seconds, default TBD.
 -i|--idle        DO NOT display any jobs in state 'idle'. 
 --[no]legend     Disable or enable showing of the legend, default on. 

 rundir           directory to monitor, default is CWD. [currently unused]

EOF
    exit ($flag ? 1 : 0); 
}

sub myversion() {
    my $version = version();
    print "Pegasus $version, @{[basename($0)]} $main::revision\n"; 
    exit 0; 
}

sub trim($) { 
    # purpose: remove leading and trailing whitespace, quotes around
    # paramtr: $s (IN): a string
    # returns: possibly shortened string
    #
    my $s = shift;
    $s =~ s/^\s+//;
    $s =~ s/\s+$//;
    $s = substr($s,1,-1) if substr($s,0,1) =~ /[""'']/;
    $s; 
}

sub commas($) {
    # purpose: put commas to separate engineering dimensions
    # paramtr: $x (IN): numerical string
    # returns: string with commas inserted as necessary
    # warning: assumes english locale
    #
    my $text = reverse shift();
    $text =~ s/(\d{3})(?=\d)(?!\d*\.)/$1,/g;
    return scalar reverse $text;
}

sub plural($$) {
    # purpose: print number space item. Add plural-s if number != 1
    # paramtr: $n (IN): count
    #          $s (IN): item string
    # returns: constructed string with proper plural
    #
    my $n = shift;
    my $s = shift;
    return "$n $s" if $n == 1;

    if ( substr($s,-1) eq 'y' ) {
        commas($n) . ' ' . substr($s,0,-1) . 'ies';
    } else {
        commas($n) . " ${s}s";
    }
}

sub initialize_winch {
    # purpose: determine rows and columns of current window
    # returns: ($rows,$cols)
    # warning: Make sure that this function stays POSIX signal safe!
    #
    my $r = $ENV{LINES} || 25; 
    my $c = $ENV{COLUMNS} || 80; 

    if ( $main::onatty ) { 
	my $ws = pack('S!4',()); 
	if ( defined &TIOCGWINSZ && ioctl( STDOUT, &TIOCGWINSZ, $ws ) ) { 
	    ($r,$c) = unpack("S!4",$ws);
	}
    } else {
	$r = $c = 1E10;	# virtually unlimited
    }

    ($r,$c); 
}

sub sigwinch {
    # purpose: adjust global $rows and $cols when window size changes
    # globals: $rows (OUT): new row count
    #          $cols (OUT): new column count
    # warning: Make sure that this function stays POSIX signal safe!
    # warning: Make sure the handler is only installed for ttys!
    #
    my $ws = pack('S!4',()); 
    if ( defined &TIOCGWINSZ && ioctl( STDOUT, &TIOCGWINSZ, $ws ) ) { 
	($rows,$cols) = unpack("S!4",$ws);
    }
}

sub interval($) {
    # purpose: convert a number of seconds into days, hours, mins, secs
    # paramtr: $s (IN): total number of seconds
    # returns: formatted string with or without days
    #
    use integer;
    my $total = shift;
    my $s = $total % 60;
    my $m = ($total % 3600) / 60; 
    my $h = ($total % 86400) / 3600;
    my $d = $total / 86400; 

    if ( $total < 3600 ) { 
	# no days or hours
	sprintf "%02d:%02d", $m, $s;
    } elsif ( $total < 86400 ) { 
	# no days, don't show days
	sprintf "%02d:%02d:%02d", ($total / 3600), $m, $s;
    } else {
	my $h = ($total % 86400) / 3600;
	my $d = $total / 86400; 
	sprintf "%d+%02d:%02d:%02d", $d, $h, $m, $s;
    }
}

sub fit($$) {
    # purpose: fit a string into a given width
    # paramtr: $width (IN): maximum space
    #          $s (IN): input string to format
    # returns: formatted string
    # 
    my $width = shift; 
    my $s = shift;
    my $len = length($s); 

    if ( $width != 0 && $len > abs($width) ) {
	if ( $width < 0 ) {
	    # fit from back
	    '..' . substr($s,($len+$width)+2);
	} else {
	    # forward fit
	    substr($s,0,$width-2) . '..';
	}
    } else {
	$s;
    }
}

sub kickstart($) {
    # purpose: remove kickstart arguments from commandline
    # paramtr: job classad 'Arguments' value
    # returns: remaining commandline, with kickstart removed
    # warning: also applies 'basename' to all absolute filenames
    #
    my @arg = split /\s+/, shift(); # FIXME: deal with quoting properly!
    my @result = ();
    my $state = 0;
    for ( my $i=0; $i<@arg; ++$i ) {
	if ( $state == 0 ) {
	    if ( substr($arg[$i],0,1) eq '-' ) {
		my $opt = substr($arg[$i],1,1);
		if ( index('ioelnNRBLTIwWSs',$opt) >= 0 ) {
		    # skip argument
		    ++$i;
		} elsif ( index('HVX',$opt) >= 0 ) {
		    # do nothing
		} else {
		    warn "Warning: Unknown kickstart argument $arg[$i]\n";
		}
	    } else {
		# this better be the application that we are starting
		$state = 1;
		push( @result, basename($arg[$i]) );
	    }
	} else {
	    # we can only apply basename to absolute filenames, because
	    # those are the only element we can recognize as such. 
	    if ( substr($arg[$i],0,1) eq $main::dirsep ) {
		push( @result, basename($arg[$i]) );
	    } else {
		push( @result, $arg[$i] );
	    }
	}
    }

    wantarray ? @result : join( ' ', @result );
}

sub seqexec(\%) {
    # purpose: count number of jobs in seqexec input file
    # paramtr: %r (IN): job class ad representation
    # returns: number of seqexec sub-jobs
    #
    my $r = shift;
    my $result = 0;

    my $fn = File::Spec->rel2abs( $r->{in}, $r->{iwd} );
    if ( open( S, "<$fn" ) ) {
	my @ok = ();
	while ( <S> ) {
	    s/[ \r\n]+$//;
	    s/\#.*//;
	    next if length($_) < 3;
	    push( @ok, $_ );
	}
	close S;
	$result = @ok+0;
    } else {
	warn "Warning: open $fn: $!, skipping\n"
	    if $main::debug > 3; 
    }

    $result;
}

sub cstat($) {
    # purpose: parse condor job state into string.
    # paramtr: $s (IN): job classad 'JobStatus'
    # returns: string representing Condor job state
    #
    my $s = shift;
    $s < @main::cstat ? $main::cstat[$s] : "$s";
}

sub gstat($) { 
    # purpose: parse condor job globus state into string.
    # paramtr: $s (IN): job classad 'GlobusStatus' (may be undef)
    # returns: string representing Globus job state
    #
    my $s = shift;
    if ( defined $s ) { 
	exists $main::gstat{$s} ? $main::gstat{$s} : "$s";
    } else {
	'-';
    }
}

sub parsersl($) { 
    # purpose: Parse a Globus RSL string into hash
    # paramtr: $rsl (IN): RSL string
    # returns: hash representing RSL values
    # warning: all keys will be canonicalized
    #
    my %result = (); 
    local $_ = shift; 
    while ( /\(([^)]+)\)/g ) {
        my ($k,$v) = split /=/, $1, 2;
	$k =~ s/[-_]//g;
	$result{lc $k} = $v;
    }
    %result;
}

sub condor_q(\%\%\@;%) {
    # purpose: Parse entire Condor-Q into hash of job classad hashes
    # paramtr: %jobs (OUT): parsed job classads indexed by 'clusterid'
    #          %dags (OUT): maps dagmanjobid to array of clusterids
    #          @t    (IN): ask condor_q only for these keys 
    #          %flag (IN): key value pairs controlling behavior
    # globals: $main::user (IN): which user to limit output to
    #          %main::title (IN): determines which keys to ask for
    #          %main::count (OUT): updates statistics for Condor/Globus jobs.
    #
    my $jobref = shift;
    my $dagref = shift;
    my $t      = shift; 
    my %flags = ( @_ ); 

    local(*Q);
    my $condor_q = find_exec('condor_q') ||
	die "FATAL: Unable to find 'condor_q' in your PATH.\n"; 

    if ( defined $main::cache && $main::cache ) { 
	# see --cache flag -- THIS IS ONLY FOR DEBUGGING
	open( Q, $main::cache ) || die "open $main::cache: $!\n"; 
    } else {
	# FIXME: 'condor_q' is expensive. Find better restrictions!
	open( Q, "$condor_q -l $main::user|" ) ||
	    die "FATAL: Unable to execute $condor_q: $!\n"; 
    }

    # skip intro
    while ( <Q> ) { 
	last if /^--/;
    }

    my (%db,@x);
    while ( <Q> ) { 
	s/[\r\n]+$//; 		# safe chomp
	if ( length($_) > 2 ) { 
	    # regular job classad
	    @x = split /\s+=\s+/, $_, 2;
	    die "this must not happen!" if exists $db{lc($x[0])}; 
	    $db{lc($x[0])} = trim($x[1]); 
	} else {
	    my $id = $db{clusterid}; 

	    # extra sanity?
	    die "nothing in queue?" unless scalar keys %db; 
	    die "nothing in cluster" unless defined $id; 

	    # noidle for Mats
	    unless ( $flags{noidle} && $db{jobstatus} == 1 ) {
		# add parsed job classads to %job
		$jobref->{$id} = { %db }; 

		# Add job belonging to a dagman to %dag
		# A dagman job will always be started prior to the job it starts,
		# thus the (condor) job for the DAGMan exists for alive DAGMans. 
		if ( exists $db{dagmanjobid} && exists $jobref->{ $db{dagmanjobid} } ) {
		    push( @{ $dagref->{ $db{dagmanjobid} } }, $id );
		} else {
		    # we need this branch for Condor jobs not managed by DAGMan,
		    # or for Condor jobs whose parent DAGMan died.
		    $dagref->{$id} = [] unless exists $dagref->{$id}; 
		}
	    }

	    # bookeeping
	    if ( exists $flags{count} ) {
		$flags{count}{condor}{ $db{jobstatus} }++;
		$flags{count}{all}{condor}++;
		if ( exists $db{globusstatus} ) {
		    $flags{count}{globus}{ $db{globusstatus} }++;
		    $flags{count}{all}{globus}++;
		}
	    }

	    # prepare for next round
	    %db = (); 
	}
    }

    # extra sanity? 
    die "hmm, maybe condor_q output formatting changed?" if scalar keys %db;

    close Q;
    if ( $main::debug ) { 
	warn "Warning: condor_q returned ", parse_exit($?), "\n" if $?; 
    }
}

sub find_leaves(\%) {
    # purpose: determine which are the top-level jobs to show
    # paramtr: %dag (IN): dag dependencies
    # returns: hash of leave jobs in queue
    #
    my $dagref = shift; 

    # find children and parents that are dags
    my (%parent,%leaves);
    foreach my $d ( keys %{$dagref} ) {
	foreach my $v ( @{$dagref->{$d}} ) {
	    $parent{$v}{$d} = 1	if exists $dagref->{$v};
	}
    }

    # find leaves
    my @fifo = keys %{$dagref};
    while ( @fifo ) {
	my $d = pop(@fifo);
	if ( exists $parent{$d} ) {
	    push( @fifo, keys %{$parent{$d}} );
	} else {
	    $leaves{$d} = 1;
	}
    }

    %leaves; 
}

sub assemble_job($;$) {
    # purpose: create the data columns for a given job
    # paramtr: $r (IN): job classad hashref
    #          $indent (IN): what to use for indentation 
    # globals: $main::time (IN): current time cache
    # returns: updated job classad hashref
    #
    my $r = shift; 		# job classad
    my $indent = shift || ''; 

    # extra sanity?
    confess "no job?" unless scalar keys %{$r}; 
    $r->{_indent} = $indent; 

    $r;
}

sub assemble_dag($$$;$);		# { } 
sub assemble_dag($$$;$) {
    # purpose: create the data rows for a given dag job
    # paramtr: %job (IN): see condor_q
    #          %dag (IN): see condor_q
    #          $dagid (IN): which workflow to assemble
    #          $indent (IN): what to use for indentation 
    # returns: ordered list (rows) of job classad refs (cols)
    # 
    my $jobref = shift;
    my $dagref = shift;
    my $dagid = shift;
    my $indent = shift || ''; 
    my @result = (); 

    # show dagman itself
    push( @result, assemble_job( $jobref->{$dagid}, $indent ) ); 
    delete $main::seen{$dagid}; 

    # show dependent jobs for dagman
    my @x = sort { $a <=> $b } @{ $dagref->{$dagid} }; 
    $indent = $main::graph[2] x ( length($indent) / length($main::graph[0]) );
    for ( my $j=0; $j < @x; ++$j ) { 
	# extra sanity? 
	die "unknown job" unless scalar keys %{$jobref->{$x[$j]}}; 

	my $conn = $main::graph[ $j == $#x ];
	if ( exists $dagref->{$x[$j]} ) {
	    push( @result, assemble_dag( $jobref, $dagref, $x[$j], "$indent$conn" ) ); 
	} else {
	    push( @result, assemble_job( $jobref->{$x[$j]}, "$indent$conn" ) ); 
	}
	delete $main::seen{$x[$j]}; 
    }

    @result; 
}

sub x_jobstatus {
    my $row = shift;
    cstat( $row->{jobstatus} ); 
}

sub x_in_state {
    my $row = shift;
    interval( $main::time - $row->{enteredcurrentstatus} );
}

sub x_jobpriority {
    my $row = shift;
    $row->{jobprio};
}

sub x_cgstatus {
    my $row = shift; 
    cstat( $row->{jobstatus} ) . '/' . gstat( $row->{globusstatus} );
}

sub x_condorid {
    my $row = shift;
    $row->{clusterid}; 
}

sub x_job1 {
    my $row = shift; 
    my $result = ''; 

    if ( exists $row->{dagnodename} ) {
	$result = $row->{dagnodename};
    } elsif ( exists $row->{'pegasus_wf_name'} ) {
	$result = $row->{'pegasus_wf_name'};
    } else {
	my $cmd = basename( $row->{cmd} || '' );
	if ( $cmd eq 'kickstart' ) {
	    my @x = kickstart($row->{arguments});
	    $result = '*' . $x[0];
	} else {
	    $result = $cmd; 
	}
    }

    $row->{_indent} . $result;
}

sub x_job2 {
    my $row = shift; 
    my $result = ''; 

    # show dagnodename first
    if ( exists $row->{dagnodename} ) { 
	$result .= 
	    '[' . 
	    fit( -$main::width{dagnodename}, $row->{dagnodename} ) .
	    '] ';
    }

    # replace commandline ('cmd' and 'arguments')
    my $cmd = basename( $row->{cmd} || '' );

    if ( $cmd eq 'kickstart' ) { 
	$row->{iskickstarted} = 1; 
	$row->{_arguments} = $row->{arguments};
	my @x = kickstart($row->{arguments}); 
	$row->{_cmd} = $x[0]; 
	$cmd = '*' . shift(@x); 
	$row->{arguments} = join(' ',@x);
    } elsif ( $cmd eq 'seqexec' && ! exists $row->{pegasus_seqexec} ) { 
	my $n = seqexec( %{$row} ); 
	if ( defined $n && $n ) { 
	    $row->{pegasus_seqexec} = $n;
	    $cmd .= " [$n jobs]"; 
	}
    }

    $result .= $cmd; 

    # add workflow name 
    if ( exists $main::dagman_p{$cmd} && exists $row->{'pegasus_wf_name'} ) {
	$result .= ' [' .
	    fit( -$main::width{'pegasus_wf_name'}, $row->{'pegasus_wf_name'} ) .
	    ']';
    }

    $row->{_indent} . $result; 
}

sub whittle_down(\@\@) {
    # purpose: taken a full queue and reduce to only columns that we'll show
    # paramtr: @title (IN): which expert level of @title
    #          @q (IN): array of job classads as hashes
    # globals: %title (IN): find the function pointer to create column
    # returns: array of columns to show for the given job row
    #
    my $t = shift;
    my $q = shift;
    my @result = (); 

    for my $row ( @{$q} ) {
	my @y = (); 
	foreach my $k ( @{$t} ) { 
	    push( @y, &{$title{$k}{function}}( $row ) );
	}
	push( @result, [ @y ] ); 
    }

    @result; 
}

sub signum($) { 
    # purpose: signum function
    # paramtr: $x (IN) number
    # returns: -1 for negative $x, +1 for positive $x and 0 for $x==0
    #
    my $x = shift; 
    ( $x < 0 ? -1 : ( $x > 0 ? 1 : 0 ) );
}

sub column_widths(\@\@) {
    # purpose: compute width of output column from data requirements
    # paramtr: @title (IN): which expert level of @title
    #          @q (IN): array of job classads as hashes
    # globals: %title (IN): minimum column width 
    # returns: array of column width. 
    # warning: The last column is adjust to the screen width
    #
    my $t = shift;		# @title[expert] ref
    my $q = shift; 		# array of hash ref
    my @max = ();
    my @sgn = (); 

    # start with title minimum width
    foreach my $k ( @{$t} ) { 
	my $x = $title{$k}{width};
	push( @max, abs($x) );
	push( @sgn, signum($x) ); 
    }

    # determine the width of each column, but no smaller than the title width
    foreach my $row ( @{$q} ) {
	for ( my $i=0; $i < @{$row}; ++$i ) { 
	    my $len = length( $row->[$i] ); 
	    $max[$i] = $len if $len > $max[$i]; 
	}
    }

    # fix last column to match maximum terminal width
    my $s = 0; 
    for ( my $i=0; $i < @max; ++$i ) {
	$s += $max[$i] + 1; 
    }
    if ( $s > $cols ) {
	$s -= $max[$#max];
	$max[$#max] = $cols - $s;
	$max[$#max] = 0 if $max[$#max] < 0; 
    }

    # return results
    map { $max[$_] * $sgn[$_] } 0 .. $#max;
}

#
# --- main -------------------------------------------------
#

# parse CLI options
my $noidle = 0; 
my $expert = 0; 
my $legend = 1; 
my ($watch);
GetOptions( 'help|h' => \&usage
	  , 'user|u=s' => \$main::user
	  , 'debug|d+' => \$main::debug
	  , 'verbose|v+' => \$expert
	  , 'version|V' => \&version
	  , 'idle|i!' => \$noidle
	  , 'legend!' => \$legend
	  , 'watch|w:i' => sub {
	      if ( ! $main::onatty ) {
		  warn "FATAL: --watch requires a terminal for output\n"; 
		  exit 42; 
	      } else {
		  unless ( defined &TIOCGWINSZ ) { 
		      warn( "Info: Your Perl installation is incomplete. Your sysadmin could\n", 
			    "run h2ph with proper args to create sys/ioctl.ph and friends.\n" ); 
		      sleep(3); 
		  }
	      }
	      #$watch = $_[1] || 30; # 30s or 60s will be 'production'
	      $watch = $_[1] || 5; 
	  }
	  , 'cache=s' => \$main::cache
	  , 'color' => sub { $main::onatty = 1 }
	  );

# react to changes in terminal size
$SIG{WINCH} = \&sigwinch if ( defined &TIOCGWINSZ && $main::onatty );

# determine UTF-8 capabilities
if ( $main::onatty && $main::isutf8 ) { 
    # draw UTF-8 graphics
    @main::graph = ( "\xE2\x94\x9c\xE2\x94\x80", 
		     "\xE2\x94\x94\xE2\x94\x80",
		     "\xE2\x94\x82 " );
} else {
    # assume ASCII graphics
    @main::graph = ( '|-', '\_', '| ' ); 
}

my $run = shift;
# NEW: Default to cwd if nothing was specified
unless ( defined $run ) {
    $run = getcwd();
    my $brainfn = File::Spec->catfile( $run, $Pegasus::Common::brainbase );
    undef $run unless -r $brainfn; 
} else {
    $run = abs_path($run);
}

for ( my $cursor=1; ; $cursor=1 ) { 
    # in watch mode
    if ( defined $watch ) { 
	($rows,$cols) = initialize_winch(); 
	print "\033[2J\033[H";
	$main::time = time(); 
	my $now = scalar localtime($main::time); 
	my $msg = 'Press Ctrl+C to exit'; 
	printf "$msg%*s\n\n", $cols-length($msg), $now; 
	$cursor += 2; 
    }

    %main::count = (); 
    my (%job,%dag,@result);
    condor_q( %job, %dag, @{$title[$expert]}, 
	      noidle => $noidle, count => \%main::count );

    # seen is for sanity checks
    %main::seen = map { $_ => 1 } keys %job;

    # collect data to show into @result
    my %leaves = find_leaves(%dag); 
    my @q = (); 
    foreach my $id ( sort { $a <=> $b } keys %leaves ) {
	push( @q, assemble_dag( \%job, \%dag, $id ) ); 
    }

    # Are there are Condor jobs in the Q
    if ( @q > 0 ) { 
	# create data to actually show from potentially larger set
	@result = whittle_down( @{$title[$expert]}, @q ); 

	# determine dynamic column widths
	my @max = column_widths( @{$title[$expert]}, @result ); 
	
	#
	# print legend (requested by Ewa)
	#
	if ( $legend ) { 
	    my $p = 0;
	    for ( my $i=0; $i<@max; ++$i ) { 
		my $k = $title{ $title[$expert][$i] }{header};
		my $v = $title{ $title[$expert][$i] }{legend}; 
		
		my $s = '';
		$s .= $main::bold if $main::onatty;
		$s .= $k;
		$s .= $main::reset if $main::onatty; 
		$s .= ': ' . $v; 
		if ( $p + length($k) + length($v) + 1 > $cols ) { 
		    print "\n$s";
		    ++$cursor;
		    $p = length($k)+length($v)+1; 
		} else {
		    print ' ' if $i; 
		    print $s; 
		    $p += length($k)+length($v)+2; 
		}
	    }
	    print "\n\n";
	    $cursor += 2; 
	}

	#
	# print headers
	#
	print $main::bold if $main::onatty; 
	for ( my $i=0; $i<@max; ++$i ) {
	    print ' ' if $i; 
	    printf "%*s", $max[$i], $title{ $title[$expert][$i] }{header}; 
	}
	print $main::reset if $main::onatty; 
	print "\n";
	++$cursor; 
	
	# print each row of results
	for ( my $i=0; $i<@result; ++$i ) { 
	    my $jobstatus = $q[$i]->{jobstatus}; 

	    # decide on color for row and print data columns
	    print $main::color[$jobstatus] if $main::onatty;
	    for ( my $j=0; $j<@{$result[$i]}; ++$j ) {
		print ' ' if $j; 
		printf "%*s", $max[$j], $result[$i][$j]; 
	    }

	    # HELD jobs get a separate line with the hold reason
	    if ( $jobstatus == 5 ) {
		print "\n", $main::graph[1], fit( $cols-2, $q[$i]{holdreason} );
		++$cursor;
	    }
	    print $main::reset if $main::onatty;

	    # transient trickery for verbose mode
	    # NOTE: This part will likely move away
	    if ( $main::debug ) { 
		my $m = $main::debug == 1 ? 
		    qr{^(?:pegasus|wf)_} :
		    qr{^(?:(?:pegasus|wf)_|job|globus)} ;
		my $p = $cols + $cols; 
		my ($s); 
		foreach my $k ( sort keys %{$q[$i]} ) {
		    if ( $watch && $cursor > $rows-6 ) {
			print " ..";
			last; 
		    }
		    if ( $k =~ /$m/o ) { 
			my $v = $q[$i]->{$k}; 
			my $l = length($k) + length($v); 
			$s = '';
			$s .= "\033[30;1m" if $main::onatty;
			$s .= $k;
			$s .= $main::reset if $main::onatty; 
			$s .= '=' . $v; 
			if ( $p+$l+2 > $cols ) { 
			    print "\n\t$s"; 
			    ++$cursor;
			    $p = $l+9; 
			} else {
			    print " $s";
			    $p += $l+2;
			}
		    }
		}
	    }
	    
	    print "\n"; 
	    ++$cursor;

	    if ( $watch && @result > $rows-5 && $cursor > $rows-5 ) {
		print "(", plural( @result-$cursor, 'additional job' );
		print " omitted.)\n";
		++$cursor; 
		last;
	    }
	}

	# create Condor job summary
	print "\n", plural(@result,'job'), " total"; 
	++$cursor; 
	my $f = 0;
	foreach my $c ( sort { $a <=> $b } keys %{$main::count{condor}} ) {
	    print( $f++ ? ' ' : ' (' );
	    print $main::color[$c] if $main::onatty; 
	    print $main::cstat[$c], ':', commas($main::count{condor}{$c}); 
	    print $main::reset if $main::onatty; 
	}
	print ')' if $f; 
	print "\n"; 
	++$cursor; 
    }

    # are we sane? 
    warn "\n(Debug: I appear to be missing some jobs)\n" 
	if ( scalar %main::seen );

    if ( defined $watch ) { 
	sleep($watch);
    } else { 
	last;
    }
}

exit 0;
