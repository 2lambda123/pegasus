#!/usr/bin/perl -w
# author Prasanth Thomas
# propose: Runs statistics tools on pegasus workflow execution

use strict; # Perl pragma to restrict unsafe constructs
use FileHandle; #  Supply object methods for filehandles
use Getopt::Long qw(:config no_ignore_case bundling); #  Extended processing of command line options
use Term::ANSIColor qw(:constants colored); # Color screen output using ANSI escape sequences
$Term::ANSIColor::AUTORESET = 1;
use Data::Dumper; # help debug
use File::Basename;
use File::Path qw(rmtree);
use File::Copy;
use File::Spec;
use File::Temp qw/ tempfile tempdir  /;

# use local modules
use Work::Common;

my $MAX_LOG_FILE = 1000;
my $job_state_file_name = 'jobstate.log';
my ($log_dir) = tempdir('pegasus_statistics_XXXX' , TMPDIR=> 1) or die "Unable to create temp directory. $!";
&main();


sub print_usage() {
	print "\n";
	print "Usage : pegasus-statistics <submit directory> \n";
	print GREEN "Optional :\n";
	print "\t -o|--output: write outputs in given directory\n";
	print "\t -m|--monitord: invokes pegasus-monitord before running pegasus-statistics\n";
	print "\t -c|--condor: specifies a pure condor run with no GRID_SUBMIT events\n";
	print "\t -k|--keep: keeps the logs of the pegasus-statistics run  \n";
	print "\t -h|--help: display this help message\n";
}

sub main(){
	my ($help,$keep,$monitord, $condor,$verbose)=(undef,undef,undef,undef,0);
	my ($output_dir) =(undef);
	
	if(!GetOptions(
		"output|o=s"=>\$output_dir,
		"monitord|m"=>\$monitord,
		"condor|c"=>\$condor,
		"keep|k"=>\$keep,
		"help|h"=>\$help)){
			 print "Unable to parse the options .$!\n";
			 print_usage();
			 exit 1;
		}
		
		
	if ($help){
		print_usage();
		exit 0;
	}
	
	if(!$ARGV[0]){
		print "You need to provide submit directory. \n";
		print_usage();
		exit 1;
	}
	my ($submit_dir) = $ARGV[0];
	
	#sanity check first                                                                                                                            
	if( !defined $ENV{PEGASUS_HOME} ){
	    print STDERR "ERROR: PEGASUS_HOME is not set. Please source the setup-with-pegasus script.\n";
	    exit 1;
	}
	my (%config) = slurp_braindb( $submit_dir ) or die "ERROR: open braindump.txt in directory $submit_dir: $!\n";
	my($dag_file_name , $jsd_file_path) =  ($config{'dag'} ,$config{'jsd'});
	
	if(!$dag_file_name){
			print STDERR "ERROR: Unable to find the dag file name in the braindump.txt file.\n";
			exit 1;
	}
	if(!$jsd_file_path){
			print STDERR "ERROR: Unable to find the jobstate file path in the braindump.txt file.\n";
			exit 1;
	}
	
	
	
	if($monitord){
		my $job_state_backup = undef;
		my ($job_state_base_file)= File::Spec->catfile( $submit_dir, $job_state_file_name);
		if(-e "$job_state_base_file"){
			# Invoke only if jobstate.log is there
			$job_state_backup = setup_monitord($job_state_base_file);
		}
		my($dagman_out_file) = File::Spec->catfile( $submit_dir ,$dag_file_name .".dagman.out");
		my($monitord_status , $monitord_status_msg , $monitord_summary_msg)  = invoke_monitord($dagman_out_file,$jsd_file_path );
		print "$monitord_status_msg\n";
		if($monitord_status !=0 ){
			if($job_state_backup){
			# Revert back the jobstate file
				if(!move($job_state_backup ,$job_state_base_file)) {
					print STDERR "ERROR : Failed to create a revert back the jobstate file . $! \n";
				}
			}
			
			exit 1;
		}
		
	}
	
	if(!$output_dir){
		$output_dir =  File::Spec->catdir($submit_dir,"statistics");
		if (-d "$output_dir") {
			print STDERR "WARNING: Output directory $output_dir exists. Overwriting the contents ....\n";
			rmtree($output_dir) or die "Unable to delete $output_dir . $! \n";
		}
		mkdir ($output_dir) or die "Unable to create $output_dir . $! \n";
	}else{
		if (!(-d "$output_dir")) {
			print STDERR "WARNING: Output directory $output_dir doesn't exists. Creating the directory ....\n";
			mkdir ($output_dir) or die "Unable to create $output_dir . $! \n";
		}
	}
	
	my($dag_file_path) =  File::Spec->catfile("$submit_dir","$dag_file_name");
	
	# Executing genstat command
	my($genstats_status , $genstats_status_msg ,$genstats_summary_msg) =run_genstats($dag_file_path ,$jsd_file_path,$output_dir );
	print "$genstats_status_msg \n";
	## Executing genstats-breakdown command
	my($genstats_breakdown_status , $genstats_breakdown_status_msg ,$genstats_breakdown_summary_msg) =run_genstats_breakdown($dag_file_path ,$submit_dir ,$output_dir ,$condor  );
	print "$genstats_breakdown_status_msg \n";
	
	
	if(!$keep){
		rmtree($log_dir) or die "Unable to delete $log_dir . $! \n";
	}else{
		print "Logs are stored at $log_dir \n";
	}
	
	print "************* SUMMARY *******************\n";
	
	print $genstats_summary_msg.$genstats_breakdown_summary_msg;
	
	print "*****************************************\n";
	
	exit 0;
}


sub invoke_monitord($$){
# purpose : executing pegasus-monitord command
# returns : status code and status message

	my($dagman_out_file,$job_state_file) = @_;
	my(@args);
	my $status_msg = "******  pegasus-monitord  ***** \n";
	my $summary_msg;
	# Adding arguments
	push(@args ,"-j ".$job_state_file); # adding color option
	push(@args ,"$dagman_out_file"); #/adding show-jobnames option
	
	# create pegasus-monitord command
	my (@pegasus_monitord_directory_path) = ("$ENV{PEGASUS_HOME}","bin");
	my ($pegasus_monitord_path) =  File::Spec->catfile( @pegasus_monitord_directory_path, 'pegasus-monitord');
	my ($pegasus_monitord_command) = "$pegasus_monitord_path ".join(" ",@args);
	
	
	$status_msg .= "Executing command :-\n$pegasus_monitord_command \n";
	my($status,$exec_msg) = execute_command($pegasus_monitord_command,'pegasus-monitord');
	if($status == 0  ){
		$status_msg .= "****** Finished executing pegasus-monitord  ***** \n";
		$summary_msg = "Finished executing pegasus-monitord\n";		
	}else{
		$status_msg .= "ERROR : Failed to execute pegasus-monitord command . $exec_msg\n";
		$summary_msg ="ERROR : Failed to execute pegasus-monitord  . $exec_msg\n";
	}
	return ($status,$status_msg , $summary_msg);
	
}


sub setup_monitord($){
	#purpose : makes set up for pegasus-monitord command, by creating a backup of jobstate.log file
	#returns : job state backup file path
	my ($job_state_base_file) =@_;
	my ($count) =0;
	my ($job_state_tmp_file);
	while($count < $MAX_LOG_FILE){
		if($count <10){
			$job_state_tmp_file = $job_state_base_file.".00".$count;
		}elsif($count <100){
			$job_state_tmp_file = $job_state_base_file.".0".$count;
		}else{
			$job_state_tmp_file = $job_state_base_file.".".$count;
		}
		if(-e "$job_state_tmp_file"){
			$count++;
		}else{
			if(!move($job_state_base_file,$job_state_tmp_file)) {
				print STDERR "ERROR : Failed to create a backup of jobstate file  $job_state_base_file . $! \n";
				exit 1;
			}
			return $job_state_tmp_file;
		}	
	}
	print STDERR "ERROR : Failed to create a backup of jobstate file  $job_state_base_file . Exceeded the rotation limit. \n";
	exit 1;
}


sub run_genstats($$$){
# purpose : executing genstats command
# returns : status code and status message
	my(  $dag_file_path , $jobstate_log, $output_dir  )=(@_);
	my(@args);
	my $status_msg .= "******  genstats *****  \n";	
	my $summary_msg;
	
	#Adding arguments
	push(@args ,"--dag ".$dag_file_path); # adding dag file argument
	push(@args ,"--output ".$output_dir); #/adding output dir argument
	push(@args ,"--jobstate-log ".$jobstate_log); # adding job state argument	
	
	# creating genstats command 
	my (@genstats_directory_path) = ("$ENV{PEGASUS_HOME}","libexec","statistics" );
	my ($genstats_path) =  File::Spec->catfile( @genstats_directory_path, 'genstats');
	my ($genstats_command) = "$genstats_path ".join(" ",@args);
	
	$status_msg .= "Executing command :-\n $genstats_command \n";
	my($status,$exec_msg) = execute_command($genstats_command,'genstats');
	if($status == 0  ){
		$status_msg .= "****** Finished executing genstats  ***** \n";
		$status_msg .= "The genstats result is created at $output_dir \n************ \n";
		$summary_msg = "The genstats result is created at $output_dir\n";		
	}else{
		$status_msg .= "ERROR : Failed to execute genstats command . $exec_msg\n";
		$summary_msg = "ERROR : Failed to create job statistics . $exec_msg\n";
	}
	return ($status,$status_msg,$summary_msg);
	
}

sub run_genstats_breakdown($$$$){
# purpose : executing genstats-breakdown command
# returns : status code and status message
	my ($dag_file_path , $submit_dir , $output_dir ,$condor )=(@_);
	my (@args);
	my ($submit_dirs) = $submit_dir;
	my (@sub_workflow_submit_dirs) = get_sub_workflow_list($dag_file_path);
	my ($number_of_elements) = scalar(@sub_workflow_submit_dirs);
	my $summary_msg;
	
	if($number_of_elements > 0){
		invoke_tailstatd_for_sub_workflow(@sub_workflow_submit_dirs);
		$submit_dirs .= " ".join(" ",@sub_workflow_submit_dirs);
	}
	my $submit_dirs_file =&create_submit_directories_file($submit_dirs);
    my $status_msg .= "******  genstats-breakdown *****  \n";
    my $output_file = 	File::Spec->catfile($output_dir ,"breakdown.txt");
	#Adding arguments
	push(@args ,"--output ".$output_file); #/adding output file argument
	if($condor){
		push(@args ,"--condor"); #/adding output file argument
	}
	push(@args ,"-f ".$submit_dirs_file); #adding submit directories
	
	# creating genstats-breakdown command 
	my (@genstats_breakdown_directory_path) = ("$ENV{PEGASUS_HOME}","libexec","statistics");
	my ($genstats_breakdown_path) =  File::Spec->catfile( @genstats_breakdown_directory_path, 'genstats-breakdown');
	my ($genstats_breakdown_command) = "$genstats_breakdown_path ".join(" ", @args);
	
	$status_msg .= "Executing command :-\n $genstats_breakdown_command \n";
	my($status,$exec_msg) = execute_command($genstats_breakdown_command, 'genstats_breakdown');
	if($status == 0  ){
		$status_msg .= "****** Finished executing genstats-breakdown  ***** \n";
		$status_msg .= "The genstats breakdown result is created at $output_file \n************ \n";
		$summary_msg = "The genstats breakdown result is created at $output_file\n";
	}else{
		$status_msg .= "ERROR:Failed to execute genstats-breakdown command . $exec_msg\n";
		$summary_msg ="ERROR:Failed to create statistics of logical transformations . $exec_msg\n";
	}
	return ($status , $status_msg,$summary_msg);
	
}

sub invoke_tailstatd_for_sub_workflow(@){
	my(@sub_workflow_submit_dirs) = @_;
	
	foreach my $submit_dir (@sub_workflow_submit_dirs) {
		my (%config) = slurp_braindb( $submit_dir ) or die "ERROR: open braindump.txt in directory $submit_dir: $!\n";
		my($dag_file_name , $jsd_file_path) =  ($config{'dag'} ,$config{'jsd'});
		if(!$dag_file_name){
				print STDERR "ERROR: Unable to find the dag file name in the braindump.txt file in $submit_dir.\n";
				exit 1;
		}
		if(!$jsd_file_path){
				print STDERR "ERROR: Unable to find the jobstate file path in the braindump.txt file in $submit_dir.\n";
				exit 1;
		}
		my $job_state_backup = undef;
		my ($job_state_base_file)= File::Spec->catfile( $submit_dir, $job_state_file_name);
		if(-e "$job_state_base_file"){
			# Invoke only if jobstate.log is there
			$job_state_backup = setup_monitord($job_state_base_file);
		}
		my($dagman_out_file) = File::Spec->catfile( $submit_dir ,$dag_file_name .".dagman.out");
		my($monitord_status , $monitord_status_msg , $monitord_summary_msg)  = invoke_monitord($dagman_out_file,$jsd_file_path );
		print "$monitord_status_msg\n";
		if($monitord_status !=0 ){
			if($job_state_backup){
			# Revert back the jobstate file
				if(!move($job_state_backup ,$job_state_base_file)) {
					print STDERR "ERROR : Failed to create a revert back the jobstate file . $! \n";
				}
			}
			
			exit 1;
		}
	}
}

sub create_submit_directories_file($){
	# purpose : creates a file with all the submit directories path.
	#returns : file path
	my($submit_dirs) =@_;
	my ($out_fh,$out_fn) = tempfile("submit_directory_XXXX",SUFFIX => '.in',DIR =>$log_dir);
	
	open ($out_fh, ">$out_fn") or die "Unable to write to file $out_fn. $! \n";
	my @submit_directories_arr = split(' ',$submit_dirs);
	foreach my $submit_dir (@submit_directories_arr) {
		print $out_fh "$submit_dir\n";
	}
	close $out_fh; 
	return $out_fn;
}

sub get_sub_workflow_list($){
	# purpose : find the list of sub workflows from the dag file
	# returns : list of sub workflows
	my($root_dag_file_path) =(@_);
	my($job_name ,$submit_file_name);
	my(@sub_workflow_list) ;
	my (@dag_path_list);
	my $dag_file_path;
	my ($dagbase,$submit_dir ,$type ) ;
    my ($submit_file_path,$sub_wf_submit_dir);
    my($sub_wf_submit_file_name);
    my (%config);
    my($sub_dag_file_name);
    my ($sub_dag_file_path);
    my(@sub_workflow_submit_dirs);
	
	push(@dag_path_list,$root_dag_file_path);
	while(@dag_path_list){
		$dag_file_path = shift(@dag_path_list);
		@sub_workflow_list =();
		open CONFIG, "$dag_file_path" or die "Unable to open dag file: $dag_file_path . $! \n";
		# Getting sub workflows from dag file
		while (my $line = <CONFIG>) {
	    	chomp $line;
	    	$line =~ s/^\s+//; 
	    	$line =~ s/^\s+//;
	    	if( $line =~m/^JOB\s.*/i ){
	    		my @values = split(/\s+/, $line);
	    		$job_name =$values[1];
	    		$submit_file_name = $values[2];
	    		if($job_name  =~m/^pegasus-plan.*/i){
	  				push(@sub_workflow_list,$submit_file_name);
	  			}
	    	}
	    }
	    close CONFIG;
	 	
	 	($dagbase,$submit_dir ,$type) = fileparse( $dag_file_path  ,qr{\..*});
	 	foreach $sub_wf_submit_file_name (@sub_workflow_list){
	 		 $submit_file_path = File::Spec->catfile($submit_dir,$sub_wf_submit_file_name);
		     $sub_wf_submit_dir = &parse_submit_file($submit_file_path);
		     if($sub_wf_submit_dir){
		        %config = slurp_braindb( $sub_wf_submit_dir ) or die "ERROR: open braindump.txt in directory $sub_wf_submit_dir: $!\n";
	     	    $sub_dag_file_name = $config{'dag'};
	     	    push (@sub_workflow_submit_dirs ,$sub_wf_submit_dir);
	     		if($sub_dag_file_name){
	     			$sub_dag_file_path = File::Spec->catfile($sub_wf_submit_dir,$sub_dag_file_name);
	     			push(@dag_path_list,$sub_dag_file_path);
		     	}else{
		     		print STDERR "WARNING: Unable to find dag file name in the braindump file in $sub_wf_submit_dir.\n";
		     	}
		     }
		     
		}   
	}
	return @sub_workflow_submit_dirs;
}

sub parse_submit_file($){
	# purpose : parses the submit file to find the 'initialdir' configuration value.
	# returns : 'initialdir' configuration value if present , undef otherwise
	
	my ($submit_file)=(@_);
	if(open CONFIG, "$submit_file"){ 
		for (<CONFIG>) {
	    	chomp;
	    	s/\#.*//;
	    	s/^\s+//;
	    	s/\s+$//;
	    	next unless length;
	    	my ($var, $val) = split(/\s*=\s*/, $_, 2);
	    	if ($var eq 'initialdir'){
	    		close(CONFIG);
				return $val;
			}
	    	
		}
		close(CONFIG);
		print STDERR "WARNING: Unable to find 'initialdir' configuration value in the submit file $submit_file.\n";
		return undef;
	}else{
		print STDERR "WARNING: Unable to open submit file: $submit_file . $! \n";
		return undef;
	}
	
}


sub  execute_command($$){
# purpose : executes command and returns the status and error message
	# returns : status and error message
	my ($command , $prefix)=(@_);
	my ($error_msg) = (undef);
	my ($out_fh,$out_fn) = tempfile($prefix."_XXXX",SUFFIX => '.out',DIR =>$log_dir);
	my ($err_fh,$err_fn) = tempfile($prefix."_XXXX",SUFFIX => '.err',DIR =>$log_dir);
	close($out_fh);
	close($err_fh);
	my($ret) = system("$command  1>$out_fn 2>$err_fn");
	if($ret != 0){
		$error_msg = $!;
	}
	return ($ret , $error_msg);
}

