#!/usr/bin/env perl
#
# processes the output from pegasus-get-sites, and does sanity checks on
# each site. 
#
# This file or a portion of this file is licensed under the terms of
# the Globus Toolkit Public License, found in file GTPL, or at
# http://www.globus.org/toolkit/download/license.html. This notice must
# appear in redistributions of this file, with or without modification.
#
# Redistributions of this Software, with or without modification, must
# reproduce the GTPL in: (1) the Software, or (2) the Documentation or
# some other similar material which is provided with the Software (if
# any).
#
# Copyright 1999-2004 University of Chicago and The University of
# Southern California. All rights reserved.
#
# Author: Jens-S. Vöckler voeckler at cs dot uchicago dot edu
# $Id: pegasus-check-sites,v 1.9 2005/11/16 23:28:35 voeckler Exp $
#
require 5.005;
use strict;
use Carp;
use Sys::Hostname;
use File::Spec;
use File::Basename;
use File::Temp qw(tempfile);
use Getopt::Long qw(:config bundling);
use POSIX qw(:sys_wait_h strftime);
use Time::HiRes qw(time);
use Digest::MD5;
use Data::Dumper;
use Socket;
use Fcntl;
use URI;

# Euryale modules
use GriPhyN::WF;		# dummy module, but required
use GriPhyN::SC;		# site catalog (SC) 
use Work::Properties qw(:parse); # ...
my $p = Work::Properties->new( PARSE_GVDS );
my $tc;
my $sc;

# prototypes
sub find_globus_tool($);	# { }
sub pipe_out_cmd($@);		# { }
sub canonical($);		# { }

# version
our $BASENAME = basename($0);
our $VERSION='1.0';
$VERSION=$1 if ( '$Revision: 1.9 $' =~ /Revision:\s+([0-9.]+)/o );

my $host = Sys::Hostname::hostname || die "Hey, your hostname is not set!\n";
my $proto = getprotobyname('tcp') || die "FATAL: getprotobyname tcp: $!\n";
my $pegasushome = $ENV{'PEGASUS_HOME'} || die "FATAL: PEGASUS_HOME is not set!\n";
if ( index( canonical(dirname($0)), $pegasushome ) == -1 ) {
    # suspicious
    warn( "WARNING: Executing in @{[canonical(dirname($0))]}, but PEGASUS_HOME=$pegasushome\n",
	  "Suspicion: $BASENAME does not match PEGASUS_HOME installation!\n",
	  "Press the interrupt button (Ctrl+C) now, if you agree.\n" );
    sleep(1);
}

my @default_timeout = qw(ping_gatekeeper ping_gridftp 
			 auth_forkjm auth_batchjm auth_gridftp
			 xfer_file run_forkjm run_batchjm);
my %default_timeout = 
    ( 'ping_gatekeeper' => 90,
      'ping_gridftp' => 150,
      'auth_forkjm' => 180,
      'auth_batchjm' => 180,
      'auth_gridftp' => 180,
      'xfer_file' => 240,
      'run_forkjm' => 300,
      'run_batchjm' => 600 );
my %timeout = ( %default_timeout ); # deep copy

$main::term = undef;		# used by pipe_out_cmd
$main::DEBUG = 0x05;
$main::parent = $$;		# myself
%main::unlink = ();		# lof to unlink@end
END { 
    while ( my ($k,$v) = each %main::unlink ) {
	unlink $k if $v == $$;
    }
}

my %tcstyle = ( old => 0, new => 1, pegasus => 2 );
my %tcxlate = ( OldFile => 'old', single => 'old', multiple => 'old',
		File => 'new', Database => 'pegasus' );
my $tcstyle = $tcxlate{$p->property('pegasus.tc')} ||
    $tcxlate{$p->property('pegasus.tc.mode')} ||
    'new'; # default TC style
my $def_tcfn = File::Spec->catfile( $ENV{'PEGASUS_HOME'}, 'var', 
				    'tc.data' );
my $tcfn = $p->property('pegasus.tc.file') || $def_tcfn;

my %scstyle = ( old => 0, new => 1, xml => 2 );
my %scxlate = ( single => 'old', multiple => 'old',, Text => 'new',
		XML => 'xml' );
my $scstyle = $scxlate{$p->property('pegasus.sc')} ||
    $scxlate{$p->property('pegasus.pool.mode')} ||
    'xml'; # default SC style is XML
my %scfiles = ( old => 'sites.txt', new => 'sites.txt', xml => 'sites.xml' );
my $def_scfn = File::Spec->catfile( $ENV{'PEGASUS_HOME'}, 'var', 
				    $scfiles{$scstyle} );
my $scfn = $p->property('pegasus.sc.file') || 
    $p->property('pegasus.pool.file') || $def_scfn;

my @intense = qw(ping light medium deep);
my %intense = ( 'ping' => [ 0, 'checks reachability (service pings)' ],
		'light' => [ 1, 'adds authentication checks to ping' ], 
		'medium' => [ 2, 'adds a fork job to authentication' ], 
		'deep' => [ 3, 'additional TC availability batch check (not yet!)' ] );
my $intense = 'medium';
my $force_batch = 0;

my ($flag2);
GetOptions( 'help' => \&usage,
	    'debug|d=o' => \$main::DEBUG,
	    'force-batch' => \$force_batch,
	    'level|l=s' => sub {
		my $level = lc($_[1]);
		die "Unknown level \"$level\"" unless exists $intense{$level};
		$intense = $level;
	    },
	    'timeout=s%' => sub {
		my $key = lc($_[1]);
		my $val = $_[2] || 0;
		if ( $key eq 'all' ) {
		    # all timeouts
		    %timeout = map { $_ => $val } @default_timeout;
		} elsif ( exists $default_timeout{$key} ) {
		    # specific timeout
		    $timeout{$key} = $val;
		} else {
		    # unknown functionality
		    die "Unknown functionality \"$key\"\n";
		}
	    },
	    'tc|t=s' => \$tcfn,
	    'tc-style|T=s' => sub {
		my $tc = lc($_[1]);
		die "Unknown style \"$tc\" for TC" unless exists $tcstyle{$tc};
		$tcstyle = $tc;
	    },
	    'pc|sc|s=s' => sub {
		$scfn = $_[1];
		$flag2 = 1;
	    },
	    'pc-style|sc-style|S=s' => sub {
		my $sc = lc($_[1]);
		die "Unknown style \"$sc\" for SC" unless exists $scstyle{$sc};
		my $f1 = ( $scfn eq $def_scfn );
		$scstyle = $sc;
		$def_scfn = File::Spec->catfile( $ENV{'PEGASUS_HOME'}, 'var',
						 $scfiles{$scstyle} );
		$scfn = $def_scfn if ( $f1 && ! defined $flag2 );
	    } );

#
# sanity checks
#
my $gpi = find_globus_tool('grid-proxy-info') || 
    die "ERROR: Unable to find grid-proxy-info\n";
die "ERROR: Unable to execute $gpi" unless -x $gpi;
my $timeleft = -1;
{
    local $main::DEBUG = 0;
    $timeleft = pipe_out_cmd( 30, $gpi, '-timeleft' );
}
die "ERROR: Error while executing $gpi: ", ($?>>8), "\n" unless ( $? == 0 );
die "ERROR: Remaining time on proxy too short\n" if $timeleft < 3600;

unless ( index($host,'.') > 0 ) {
    eval {
	$host = (uname())[1] if length($host) == 0;
	my $ipv4 = gethostbyname($host);
	die "Unable to gethostbyname($host)" unless length($ipv4) > 0;
	$host = gethostbyaddr($ipv4,AF_INET);
	die "Unable to reverse lookup $host" unless length($host) > 0;
    };
    die "ERROR: $@\n" if $@;
}
warn( "# local hostname \"$host\"\n" ) if ( ($main::DEBUG & 0x01) );

my $grun = find_globus_tool('globusrun') ||
    die "ERROR: Unable to find globusrun";
die "ERROR: Unable to execut $grun" unless -x $grun;
my $guc = find_globus_tool('globus-url-copy') ||
    die "ERROR: Unable to find globus-url-copy";
die "ERROR: Unable to execute $guc" unless -x $guc; 
my $gjr = find_globus_tool('globus-job-run') ||
    die "ERROR: Unable to find globus-job-run";
die "ERROR: Unable to execute $gjr" unless -x $gjr; 
my $uftp = find_globus_tool('uberftp') ||
    die "ERROR: Unable to find uberftp";
die "ERROR: Unable to execute $uftp" unless -x $uftp;

# show selected options after parsing
if ( $main::DEBUG ) {
    foreach my $level ( @default_timeout ) {
	warn "# timeout $level=", $timeout{$level}, "\n";
    }
}

# --- functions -------------------------------------------------
#

sub report {
    # paramtr: $start (IN): start timestamp
    my $prefix = sprintf( "%8.3f ", time() - shift() );
    syswrite( STDERR, join(' ', $prefix, @_, "\n" ) );
}

sub debug {
    syswrite( STDERR, '          ' . join(' ', @_, "\n") )
	if ( $main::DEBUG & 0x01 );
}

sub showstyle {
    my %x = @_;
    '"' . join( '", "', sort { $x{$a} <=> $x{$b} } keys %x ) . '"';
}

sub canonical($) {
    my $x = shift;
    File::Spec->rel2abs(File::Spec->canonpath($x));
}

sub usage(;$) {
    my $ec = shift;
    $ec = 1 unless defined $ec;

    print "Sanitize site catalog (SC) and transformation catalog (TC)\n";
    print '$Id: pegasus-check-sites,v 1.9 2005/11/16 23:28:35 voeckler Exp $', "\n";
    print << "EOF";

 -Dprop=val    property overwrite, required first argument(s).
 --debug|-d lv sets debug level (verbosity), default $main::DEBUG:
       0x01    enable more verbosity
       0x02    show external application invocation string
       0x04    show lines returning from invocation stdio
       0x08    show [eof] to signal when content was done
       0x10    show each dynamically loaded modules
 --timeout i   interval to wait for a check to return successfully (not yet!)
 --force-batch do not skip batch jm auth tests, if the fork jm auth failed.
 --tc|-t  fn   name of TC file to produce, 
               default $tcfn
 --sc|-s  fn   Name of SC file to produce, 
               default $scfn
 --tc-style s  style to generate the TC with, available styles are
               @{[showstyle(%tcstyle)]}; default style \"$tcstyle\". 
 --sc-style s  style to generate the SC with, available styles are
               @{[showstyle(%scstyle)]}; default style \"$scstyle\". 
 --level int.  choses a checking intensity level, default \"$intense\":
EOF
    for my $level ( sort { $intense{$a}[0] <=> $intense{$b}[0] } keys %intense ) {
	printf "               %-8s %s\n", "\"$level\"", $intense{$level}[1];
    }
    print << "EOF";
 --timeout k=v defines a timeout in seconds for the designated function:
EOF
    for my $level ( @default_timeout ) {
	printf "               %-18s %3d\n", "\"$level\"", $default_timeout{$level};
    }

    exit $ec;
}

sub load_module($$$) {
    # purpose: dynamically load a module at run-time
    # warning: This function must reside in module 'main' ???
    # paramtr: $wf (IN): workflow manager handle
    #          $match (IN): property prefix match string
    #          $base (IN): Perl name of the base module (name prefix)
    # returns: an instance towards the module, or undef for failure
    my $wf = shift || die 'workflow manager unknown';
    my %temp = ref($_[0]) eq 'HASH' ? %{ shift() } : 
	extract_properties($wf,shift()); # will die on missing arg
    my $base = shift || die "need the name of the module to load";
    no strict 'refs';

    # create module name
    $base .= '::' unless substr($base,-2) eq '::';
    my $module = $base . $temp{style};
    
    # dynamically load module at run-time
    eval "require $module;";
    die $@ if $@;
    # import the exported variable (module ISA exporter)
    $module->import() if $module->can('import');
    
    my $handle = $module->new(%temp);
    warn( '# loaded ', ref($handle), ' [', $handle->VERSION, "]\n" ) 
	if ( $main::DEBUG & 0x10 );
    $handle;
}

sub _create_backup($) {
    # purpose: creates a backup using increasing digits, and renames
    # paramtr: $fn (IN): name of original file to rename from
    # returns: undef in case of error, chosen backup filename otherwise
    my $fn = shift;

    # from "man 2 open" on Linux:                 O_EXCL is broken  on
    # NFS file systems, programs which rely on it for performing lock-
    # ing tasks will contain a race condition.  The solution for  per-
    # forming  atomic  file  locking  using  a lockfile is to create a
    # unique file on the same fs  (e.g.,  incorporating  hostname  and
    # pid),  use  link(2)  to  make  a link to the lockfile. If link()
    # returns 0, the lock is successful.  Otherwise,  use  stat(2)  on
    # the  unique  file to check if its link count has increased to 2,
    # in which case the lock is also successful.
    my $ctx = Digest::MD5->new;
    $ctx->add( $$ );		
    $ctx->add( time() );
    $ctx->add( $fn );
    my $unique = $fn . '-' . $ctx->hexdigest() . '.lck';

    local(*UNIQUE);
    open( UNIQUE, ">$unique" ) || return undef;
    close UNIQUE;		# created unique file

    my $n = 0;
    for (;;) {
	# create backup file name to attempt
	my $backup = "$fn.$n";
	$n++;

	# attempt to create link
	if ( link( $unique, $backup ) ) {
	    # success, backup did not exist previously
	    # remove link
	    unlink $unique;
	    return undef unless rename( $fn, $backup );	
	    return $backup;
	} else {
	    # failure of link call, check stat record
	    my @st = stat($unique); 
	    if ( @st == 0 ) {
		# stat call failed -- where did our file go?
		my $saverr = $!;
		unlink $unique;
		$! = $saverr;
		return undef;
	    } elsif ( $st[3] == 2 ) {
		# hard link count is 2, also success
		unlink $unique;
		return undef unless rename( $fn, $backup );
		return $backup;
	    }
	}
    }
}

sub open_with_backup(*$) {
    # purpose: open a file for writing, but back up previous instances
    # paramtr: *FD (IN): Perl file handle
    #          $fn (IN): name of file to open for writing
    # returns: undef on error, non-zero on success
    # warning: This (O_EXCL) is not NFS-safe!
    local(*FD) = shift;
    my $fn = shift;
    my $mode = ( O_WRONLY | O_CREAT | O_EXCL );

    my ($backup,$retries);
    while ( ! defined sysopen( FD, $fn, $mode, 0666 ) && ++$retries < 5 ) {
	return undef unless $!{EEXIST};
	return undef unless defined ($backup = _create_backup($fn));
	warn "# backup $fn\n# -> $backup\n";
    }

    $retries < 5;
}

sub REAPER {
    # purpose: grim reaper of child processes
    my $child;
    while ( ($child = waitpid(-1,WNOHANG)) > 0 ) {
	$main::child{$child}{exitcode} = $?;
    }
    $SIG{CHLD} = \&REAPER;
}


sub find_exec($) {
    # purpose: determine location of given binary in $PATH
    # returns: fully qualified path to binary, undef if not found
    my $program = shift;
    local($_);
    foreach ( File::Spec->path ) {
        my $fs = File::Spec->catfile( $_, $program );
        return $fs if -x $fs;
    }
    undef;
}

sub find_globus_tool($) {
    my $tool = shift;
    my $fqpn = File::Spec->catfile( $ENV{'GLOBUS_LOCATION'}, 'bin', $tool );
    unless ( -x $fqpn ) {
	# try $PATH
	die "unable to locate $tool\n" 
	    unless ( defined ($fqpn = find_exec($tool)) );
    }
    $fqpn;
}

sub pipe_out_cmd($@) {
    # purpose: exec cmd in w/o shell, and read its output
    # paramtr: $timeout (IN): when is enough
    #          @arg (IN): command and arguments, each separate
    # globals: $? (OUT): exit code of program invocation
    #          $main::term (OUT): set in case of timeout
    # returns: scalar: first line of output
    #          vector: full output
    my @result;
    local(*READ);		# protect FH
    my $start = time();
    my $timeout = shift;

    # new temporary signal handler for timeouts
    my $child;
    alarm(0);
    $main::term = undef;
    local $SIG{ALRM} = sub {
	$main::term=1; 
	if ( defined $child && $child > 0 ) { 
	    # we know the child
	    kill( 9, $child ) if kill( 15, $child ) == 0;
	} else { 
	    # we dont know a child
	    close(READ);	# SIGPIPE in child
	}
    };

    # hmm
    local $SIG{CHLD} = 'DEFAULT';

    # pipe and fork
    $child = open( READ, '-|' );
    return (wantarray ? () : undef) unless defined $child;

    # successful fork
    if ( $child ) {
	# parent
	report $start, "@_" if ( $main::DEBUG & 0x02 );
	alarm( $timeout );
	while ( <READ> ) {
	    last if $main::term;
	    chomp;
	    push( @result, $_ );
	    report $start, $_ if ( $main::DEBUG & 0x04 );
	    last if $main::term;
	}
	close( READ );
	alarm(0);
	report $start, "[eof]" if ( $main::DEBUG & 0x08 );
	undef @result if $main::term;
    } else {
	# child
	open( STDERR, ">&STDOUT" ); # dup2 STDERR onto STDOUT
	select( STDERR ); $|=1;	# autoflush
	select( STDOUT ); $|=1;	# autoflush
	exec { $_[0] } @_;
	exit(127);
    }
    @result = grep { ! /^$/ } @result; # remove empty lines
    wantarray ? @result : $result[0];
}


sub spawn(*&) {
    # purpose: executes a piece of code in a process of its own
    # paramtr: FH (IO): communication handle? 
    # paramtr: $coderef (IN): perl code, e.g. anonymous function
    # returns: undef for fork error, or pid of child
    local(*FH) = shift;
    my $coderef = shift;
    confess "spawn CODEREF" 
	unless ( @_ == 0 && $coderef && ref($coderef) eq 'CODE' );
    
    my $pid;
    if ( ! defined ($pid = fork()) ) {
	syswrite( STDERR, "cannot fork: $!" );
	return undef;
    } elsif ( $pid ) {
	$main::child{$pid} = {};
	return $pid;		# parent
    }

    # child code
    open( STDIN, '/dev/null' ) || exit 127;
    open( STDOUT, ">&FH" ) || exit 127;
    open( STDERR, ">&FH" ) || exit 127;
    exit &$coderef();
}

sub bind_and_connect (*$$$) {
    # purpose: use optional bind() follow by connect() on a socket.
    # paramtr: FTP (IN): socket filehandle
    #          $timeout (IN): maximum timeout on connect() call.
    #          $host (IN): remote hostname
    #          $port (IN): remote port number
    #          $start (IN): start timestamp
    # returns: -
    local (*FTP) = shift;
    my $host = shift;
    my $port = shift;
    my $start = shift;

    # handle G_T_P_R with local bind
    my $range = $ENV{'GLOBUS_TCP_SOURCE_RANGE'} || 
	$ENV{'GLOBUS_TCP_PORT_RANGE'};
    if ( defined $range && length($range) ) {
	my ($lo,$hi,$i) = split /\D/, $range, 2;
	my $sin;
	for ( $i = $lo; $i <= $hi; ++$i ) {
	    $sin = sockaddr_in( $i, INADDR_ANY );
	    bind( FTP, $sin ) && last;
	    die "timeout" if $main::term;
	}
	die "unable to bind to a local port\n" if ( $i > $hi );
    }

    # connect
    my $site = inet_aton($host) || die "resolve $host: $!\n";
    connect( FTP, sockaddr_in( $port, $site ) ) || die "connect: $!\n";
    die "timeout" if $main::term;
    ($port,$host) = unpack_sockaddr_in getpeername(FTP);
    report $start, 'conntected to', inet_ntoa($host) . ":$port";

    # autoflush
    my $save = select( FTP );
    $|=1;
    select( $save );
    die "timeout" if $main::term;
}

sub multiline_response (*$;$) {
    # purpose: read 1 or more lines as a response from an ftp-like protocol.
    # paramtr: FTP: is an open socket to the server to read from
    #          $timeout (opt. IN): timeout to use
    # returns: the line which features "^\d{3}\s", usually the last line.
    local (*FTP) = shift;
    my $start = shift;
    my $timeout = shift || 60;

    # I must read all my peer has to blabber: multi-line banners
    my $rin = '';
    vec($rin,fileno(FTP),1) = 1;
    my $buffer = '';
    my $retries = 0;
    my ($rout,$nfound,$line);
  OUTER:
    while ( ($nfound=select($rout=$rin,undef,undef,$timeout/7.0)) >= 0 ) {
	die "timeout" if $main::term;	# SIGALRM triggered
	if ( $nfound == 0 ) {
	    die "timed out\n" if ( ++$retries > 6 );
	} else {
	    my $size = length($buffer);
	    my $rsize = sysread( FTP, $buffer, 4096-$size, $size );
	    die "timeout" if $main::term;	# SIGALRM triggered
	    if ( $rsize < 0 ) {
		die "read: $!";
	    } elsif ( $rsize == 0 ) {
		die "unexpected EOF";
	    } else {
		# process each line right now
		my $pos;
		while ( ($pos=index($buffer,"\n")) >= 0 ) {
		    $line = substr($buffer,0,$pos);
		    $buffer = substr($buffer,$pos+1);
			
		    # process line
		    $line =~ s/[\r\n]+$//;
		    substr( $line, 62 ) = '...' if length($line) > 62;
		    report $start, $line;
		    die "illegal response: $line" unless $line =~ /^\d{3}/;
		    last OUTER if $line =~ /^\d{3}\s/;
		}
	    }
	}
    }

    $line;
}

my $rnd = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_';
my $rnd2 = $rnd x 2; 

sub create_temporary_content() {
    # purpose: create a temporary file with pseudo-random ASCII content
    # globals: $rnd (IN): set of ASCII-bet to use and permutate through
    # returns: The name of the temporary file with the random content
    my ($fh,$fn) = tempfile( 'chk-XXXXXX', 
                             SUFFIX => '.tmp',
                             UNLINK => 0, 
                             DIR => File::Spec->tmpdir() );
    print $fh scalar localtime(), ' ', hostname(), "\n";
    my $size = length($rnd);
    for ( my $i=0; $i<1024; ++$i ) {
        print $fh substr( $rnd2, $i % $size, $size ), "\n";
    }
    close $fh;
    $main::unlink{$fn} = $$;
    
    $fn;
}

sub host_port_from_jm($) {
    # purpose: extract host and port from jobmanager contact
    # paramtr: $jm (IN): a jobmanager (MJ) contact
    # returns: [0]: remote host
    #          [1]: remote port
    my $jm = shift; 
    my ($host,$port);

    debug( "parsing job manager $jm" );

    if ( index( $jm, 'http' ) == 0 ) {
	# GT4?
	my $uri = URI->new($jm);
	$host = $uri->host();
	$port = $uri->_port();
	$port = ( $jm =~ m{^https} ? 8443 : 8080 )
	    unless ( defined $port && $port > 0 );
    } else {
	# GT2?
	my $pos = index($jm,'/');
	$pos = length($jm) if $pos == -1;
	
	my $gk = substr( $jm, 0, $pos );
	$pos = index($gk,':');
	if ( $pos == -1 ) {
	    $host = $gk;
	    $port = 2119;
	} else {
	    $host = substr($gk,0,$pos);
	    $port = substr($gk,$pos+1);
	}
    }

    ( $host, $port );
}

sub host_port_from_gftp($) {
    # purpose: extract host and port from jobmanager contact
    # paramtr: $jm (IN): a gridftp server contact
    # returns: [0]: remote host
    #          [1]: remote port
    my $ftp = shift; 
    my ($host,$port);
    my $re = '^(([^:/?#]+):)?(//([^/?#]*))?';
    $ftp =~ m{$re};
    my ($schema,$hostport) = ($2,$4);
    die "FATAL: not a gridftp URI: $ftp\n" unless $schema eq 'gsiftp';

    my $pos = index( $hostport, ':' );
    if ( $pos == -1 ) {
	$host = $hostport;
	$port = 2811;
    } else {
	$host = substr( $hostport, 0, $pos );
	$port = substr( $hostport, $pos+1 );
    }

    ( $host, $port );
}

sub deal_with_error {
    # purpose: prints the error from an application operation
    # paramtr: lines from app call
    # returns: -
    foreach ( my $i = 0; $i < @_ ; ++$i ) {
	debug( "ERR[$i]", $_[$i] );
    }
}

sub extra_check($) {
    # purpose: are we unknown to the site?
    my $grid = shift;
    if ( $main::status{$grid}{'forkjm'} eq 'auth' && 
	 ( $force_batch == 0 || $main::status{$grid}{'batchjm'} eq 'auth' ) && 
	 $main::status{$grid}{'gridftp'} eq 'auth' ) {
	syswrite( STDERR, "INFO: Your user certificate appears to be unknown to the remote site\n" );
    }
}

#
# ---------------------------------------------------------------
#

sub ping_gatekeeper($;$) {
    # purpose: tries to TCP connect to all remote gatekeeper for a site
    # paramtr: $site (IN): remote site handle 
    #          $timeout (opt. IN): timeout
    # globals: %timeout (IN): determines default timeout
    # returns: hash { the jobmanager raw string
    #                 => status string (TIMEOUT, OK, various failures)
    my $site = shift;
    my $timeout = shift || $timeout{'ping_gatekeeper'};
    my @jm = ( $sc->contact( $site, 'vanilla' ),
	       $sc->contact( $site, 'transfer' ) );
    warn "# ping_gatekeeper $site\n";

    local(*PING);
    alarm(0);

    my %result = ();
    my %seen = ();
    my $start = time();
    foreach my $jm ( map { $_->[0] } @jm ) {
	my ($host,$port,$addr) = host_port_from_jm($jm);
	eval {
	    my $temp = inet_aton($host);
	    die "Unable to resolve $host" unless length($temp);
	    $addr = inet_ntoa($temp);
	    die "Unable to reverse resolve $host" unless length($addr);
	};
	goto FAILGK if ( $@ );
	if ( exists $seen{"$addr:$port"} ) {
	    $result{$jm} = $seen{"$addr:$port"};
	    next;
	}
	report( $start, "pinging gatekeeper $host:$port" );

	$main::term = undef;
	local $SIG{ALRM} = sub { $main::term=1; close PING };
	alarm $timeout;

	eval {
	    socket( PING, PF_INET, SOCK_STREAM, $proto ) ||
		die "FATAL: socket: $!";
	    bind_and_connect( PING, $host, $port, $start );

	    # hello, good-bye
	    defined send( PING, "\r\n", 0 ) || 
		die "FATAL: send CRLF: $!";
	    die "FATAL: ping timed out" if $main::term;
	};
	alarm( 0 );
	close PING;
      FAILGK:
	chomp($@) if $@;
	my $status = $main::term ? 'TIMEOUT' : ( $@ ? $@ : 'OK' );
	report( $start, "gatekeeper $host:$port ping-status \"$status\"" );
	$result{$jm} = $seen{"$addr:$port"} = $status;
    }

    alarm(0);
    %result;
}

sub ping_gridftp($;$) {
    # purpose: tries to TCP connect to all remote gridftp for a site
    # paramtr: $site (IN): remote site handle 
    #          $timeout (opt. IN): timeout
    # globals: %timeout (IN): determines default timeout
    # returns: hash { gridftp URI prefix
    #                 => status string (TIMEOUT, OK, various failures)
    my $site = shift;
    my $timeout = shift || $timeout{'ping_gridftp'};
    my @gftp = $sc->gridftp( $site );
    warn "# ping_gridftp $site\n";

    local(*FTP);
    alarm(0);

    my %result = ();
    my %seen = ();
    my $start = time();
    foreach my $ftp ( map { $_->[0] } @gftp ) {
	my ($host,$port,$addr) = host_port_from_gftp($ftp);
	eval {
	    my $temp = inet_aton($host);
	    die "Unable to resolve $host" unless length($temp);
	    $addr = inet_ntoa($temp);
	    die "Unable to reverse resolve $host" unless length($addr);
	};
	goto FAILGFTP if ( $@ );
	if ( exists $seen{"$addr:$port"} ) {
	    $result{$ftp} = $seen{"$addr:$port"};
	    next;
	}
	report( $start, "pinging gridftp server $host:$port" );

	$main::term = undef;
	local $SIG{ALRM} = sub { $main::term=1; close FTP };
	alarm $timeout;
	
	eval {
	    socket( FTP, PF_INET, SOCK_STREAM, $proto ) ||
		die "FATAL: socket: $!";
	    bind_and_connect( FTP, $host, $port, $start );

	    # I must read all my peer has to blabber: multi-line banners
	    my $line;
	    defined ($line=multiline_response( FTP, $start, $timeout )) 
		|| die "FATAL: read: $!\n";
	    die "FATAL: unexpected response 1: $line\n"
		if substr( $line, 0, 3 ) ne '220';

	    # say good-bye
	    defined send( FTP, "QUIT\r\n", 0 ) || die "FATAL: send: $!\n";
	    die "FATAL: timeout" if $main::term;

	    defined ($line=multiline_response( FTP, $start, $timeout )) 
		|| die "FATAL: read: $!\n";
	    die "FATAL: timeout" if $main::term;
	    die "FATAL: unexpected response 2: $line\n" 
		if substr( $line, 0, 1 ) ne '2';
	};
	alarm(0);
	close FTP;
      FAILGFTP:
	chomp($@) if $@; 
	my $status = $main::term ? 'TIMEOUT' : ( $@ ? $@ : 'OK' );
	report( $start, "gridftp server $host:$port ping-status \"$status\"" );
	$result{$ftp} = $seen{"$addr:$port"} = $status;
    }

    alarm(0);
    %result;
}

sub auth_forkjm($\%;$) {
    # purpose: attempts authentication against all fork jobmanagers
    # paramtr: $site (IN): site handle
    #          %good (IN): result from gatekeeper ping operation
    #          $timeout (opt. in): timeout
    # globals: %timeout (IN): determines default timeout
    # returns: hash ( job manager => [ status, wait-status ] )
    my $site = shift;
    my $good = shift;
    croak "FATAL: not a hashref" unless ref($good) eq 'HASH';
    my $timeout = shift || $timeout{'auth_forkjm'};
    my @jm = grep { $good->{$_->[0]} eq 'OK' } 
             $sc->contact( $site, 'transfer' );
    warn "# auth_forkjm $site\n";

    my %result = ();
    my $start = time();
    foreach my $jm ( map { $_->[0] } @jm ) {
	report( $start, "attempting to auth on $jm" );
	my @x = pipe_out_cmd( $timeout, $grun, '-a', '-r', $jm );
	my $rc = $main::term ? -1 : $?;
	my $status = $main::term ? 'TIMEOUT' : ( $rc == 0 ? 'OK' : 'FAILED' );
	report( $start, "authentication for $jm \"$status\"" );
	$result{$jm} = [ $status, $rc ];
	if ( $rc != 0 ) {
	    deal_with_error( @x );
	    if ( $x[0] =~ /GRAM Authentication/ &&
		 $x[0] =~ /authentication with the remote server failed/ ) {
		$main::status{$site}{'forkjm'} = 'auth';
	    }
	}
    }
	
    %result;
}

sub auth_batchjm($\%;$) {
    # purpose: attempts authentication against all batch jobmanagers
    # paramtr: $site (IN): site handle
    #          %good (IN): result from gatekeeper ping operation
    #          $timeout (opt. in): timeout
    # globals: %timeout (IN): determines default timeout
    # returns: hash ( job manager => [ status, wait-status ] )
    my $site = shift;
    my $good = shift;
    croak "FATAL: not a hashref" unless ref($good) eq 'HASH';
    my $timeout = shift || $timeout{'auth_batchjm'};
    my $start = time();
    my @jm = grep { $good->{$_->[0]} eq 'OK' } 
             $sc->contact( $site, 'vanilla' );
    warn "# auth_batchjm $site\n";

    my %result = ();
    foreach my $jm ( map { $_->[0] } @jm ) {
	report( $start, "attempting to auth on $jm" );
	my @x = pipe_out_cmd( $timeout, $grun, '-a', '-r', $jm );
	my $rc = $main::term ? -1 : $?;
	my $status = $main::term ? 'TIMEOUT' : ( $rc == 0 ? 'OK' : 'FAILED' );
	report( $start, "authentication for $jm \"$status\"" );
	$result{$jm} = [ $status, $rc ];
	if ( $rc != 0 ) {
	    deal_with_error( @x );
	    if ( $x[0] =~ /GRAM Authentication/ &&
		 $x[0] =~ /authentication with the remote server failed/ ) {
		$main::status{$site}{'batchjm'} = 'auth';
	    }
	}
    }
	
    %result;
}

sub auth_gridftp($\%;$) {
    # purpose: In the presence of uberftp, try to authenticate only
    # paramtr: $site (IN): site handle
    #          %good (IN): result from gatekeeper ping operation
    #          $timeout (opt. in): timeout
    # globals: %timeout (IN): determines default timeout
    # returns: hash ( job manager => [ status, wait-status ] )
    my $site = shift;
    my $good = shift;
    croak "FATAL: not a hashref" unless ref($good) eq 'HASH';
    my $timeout = shift || $timeout{'auth_gridftp'};
    my $start = time();
    my @gftp = grep { $good->{$_->[0]} eq 'OK' } $sc->gridftp($site);
    warn "# auth_gridftp $site\n";

    my %result = ();
    return %result if @gftp == 0;

    foreach my $x ( @gftp ) {
	my $ftp = $x->[0];	# host(:port)
	my ($host,$port,$addr) = host_port_from_gftp($ftp);
	my $hp = $host;
	$hp .= ":$port" if $port != 2811;

	report( $start, "attempting to auth against $hp" );
	my @x = pipe_out_cmd( $timeout, $uftp, '-a', 'GSI', # '-d', 
			      '-P', $port, '-H', $host, 'quit' );
	my $rc = $main::term ? -1 : $?;
	my $status = $main::term ? 'TIMEOUT' : ( $rc == 0 ? 'OK' : 'FAILED' );
	report( $start, "gridftp auth with $hp \"$status\"" );
	$result{$ftp} = [ $status, $rc ];
	if ( $rc != 0 ) {
	    deal_with_error( @x );
	    if ( grep(/^5/,@x) > 0 ) {
		$main::status{$site}{'gridftp'} = 'auth';
	    }
	}
    }

    %result;
}

sub xfer_file($\%$;$) {
    # purpose: attempts to upload a file to all gridftp servers
    # paramtr: $site (IN): site handle
    #          %good (IN): result from gridftp ping operation
    #          $fn (IN): location of file to transfer
    #          $timeout (opt. in): timeout
    # globals: %timeout (IN): determines default timeout
    # returns: hash ( job manager => [ status, wait-status ] )
    my $site = shift;
    my $good = shift;
    croak "FATAL: not a hashref" unless ref($good) eq 'HASH';
    my $fn = shift;
    my $timeout = shift || $timeout{'xfer_file'};
    my @gftp = grep { $good->{$_->[0]}->[0] eq 'OK' } $sc->gridftp( $site );

    warn "# xfer_file $site\n";
    my %result = ();
    return %result if @gftp == 0;

    my $basefn = basename($fn);
    my $start = time();
    foreach my $x ( @gftp ) {
	my $ftp = $x->[0];	# host portion
	report( $start, "attempting to upload to $ftp" );
	my $src = "file://$fn";
	my $dst = $ftp . $x->[1] . '/' . $basefn;
	my @x = pipe_out_cmd( $timeout, $guc, '-vb', $src, $dst );

	my $rc = $main::term ? -1 : $?;
	my $status = $main::term ? 'TIMEOUT' : ( $rc == 0 ? 'OK' : 'FAILED' );
	report( $start, "file transfer to $ftp \"$status\"" );
	$result{$ftp} = [ $status, $rc ];
	if ( $rc != 0 ) {
	    deal_with_error( @x );
	    if ( (grep { /530 No local mapping/i } @x) > 0 ) {
		$main::status{$site}{'gridftp'} = 'auth';
	    }
	}
    }

    # done
    %result;
}

sub simple_staged_forkjm($\%$;$) {
    # purpose: Removes remote filename, and runs some simple stuff
    # paramtr: $site (IN): site handle
    #          %good (IN): result from previous auth operation
    #          $fn (IN): location of transferred file
    #          $timeout (opt. IN): time out
    # globals: %timeout (IN): determines default timeout
    # returns: hash ( job manager => [ status, wait-status ] )
    my $site = shift;
    my $good = shift;
    croak "FATAL: not a hashref" unless ref($good) eq 'HASH';
    my $sh = File::Spec->catfile( $pegasushome, 'libexec', 'pegasus-check-helper.1' );
    my $fn = shift || croak "FATAL: Need a tmp filename";
    my $timeout = shift || $timeout{'run_forkjm'};

    my @jm = grep { $good->{$_->[0]}->[1] == 0 }
             $sc->contact( $site, 'transfer' );
    warn "# simple_staged_forkjm $site\n";

    # create arguments
    my $workdir = $sc->workdir($site);
    my $remotefn = File::Spec->catfile( $workdir, basename($fn) );
    my $script = File::Spec->canonpath(File::Spec->rel2abs($sh));
    my $argv = '&(executable=$(GLOBUSRUN_GASS_URL) # "' . $script . '")'; 
    $argv .= '(arguments="' . $remotefn . '" "' . $workdir . '" "' . 
	$sc->gridshell($site) . '")';

    my %env = $sc->profile( $site, 'env' );
    my @env = keys %env;
    if ( @env > 0 ) {
	$argv .= '(environment=';
	foreach my $key ( keys %env ) {
	    $argv .= '(' . $key . ' "' . $env{$key} . '")';
	}
	$argv .= ')';
    }

    my %result = ();
    my $start = time();
    foreach my $jm ( map { $_->[0] } @jm ) {
	report( $start, "attempting to submit to $jm" );
	my @x = pipe_out_cmd( $timeout, $grun, '-s', '-o', '-r', $jm, $argv );

	my $rc = $main::term ? -1 : $?;
	my $status = $main::term ? 'TIMEOUT' : ( $rc == 0 ? 'OK' : 'FAILED' );

	report( $start, "staged script on $jm \"$status\"" );
	$result{$jm} = [ $status, $rc ];

	if ( $rc == 0 ) {
	    # FIXME: do something with the results
	    my $x;

	    # parse SYSINFO output
	    $x = (grep(/^SYSINFO: /, @x))[0];
	    (undef,$x) = split /: /, $x, 2;
	    if ( $x eq 'UNKNOWN' || $x eq '(no network)' ) {
		debug( "Assuming remote system is an IA32 Linux" );
	    } elsif ( $x =~ /(\w+)-(\w+)(?:-(\w+))?/ ) {
		my ($os,$arch,$libc,$result) = ($1,$2,$3);
		if ( $os eq 'linux' ) {
		    if ( $arch eq 'amd64' ) {
			$result = uc($arch);
		    } elsif ( $arch =~ /i[3-6]86/ ) {
			$result = 'INTEL32';
		    } elsif ( $arch eq 'ia64' ) {
			$result = 'INTEL64';
		    } else {
			debug( "INFO: Ignoring unsupported architecture $arch" );
		    }
		    $result .= "::LINUX" if defined $result;
		} elsif ( substr($os,7) eq 'solaris' ) {
		    $result = uc($arch) . '::SUNOS';
		} else {
		    debug( "INFO: Ignoring unknown OS $os" );
		}
		if ( defined $result ) {
		    debug( "Setting site information to $result" );
		    $sc->sysinfo( $site, $result );
		}
	    } else {
		debug( "WARNING: Unable to determine remote system information" );
	    }

	    # parse KICKSTART output
	    $x = (grep(/^KICKSTART: /, @x))[0];
	    (undef,$x) = split /: /, $x, 2;
	    if ( $x eq 'INVALID' ) {
		debug( "WARNING: Remote kickstart not found!" );
	    } elsif ( $x =~ /FAILED/ ) {
		debug( "WARNING: Remote kickstart not runnable: ", substr($x,8) );
	    } elsif ( $x =~ /kickstart.c,v ([0-9.]+)/ ) {
		my ($major,$minor) = split /\./,$1,2;
		if ( $major == 1 && $minor >= 21 ) {
		    debug( "Remote kickstart is good: version $major.$minor" );
		} else {
		    debug( "WARNING: Remote kickstart version $major.$minor is too old!" );
		    debug( "Please consider deploying your own kickstart!" );
		}
	    } else {
		debug( "WARNING: Remote kickstart reported strangeness" );
	    }
	    
	} else {
	    deal_with_error( @x );
	}
    }
	
    %result;
}

sub submit_staged_batchjm($\%;$) {
    # purpose: Runs a staged shell script with arguments on fork jm
    # paramtr: $site (IN): site handle
    #          %good (IN): result from previous auth operation
    #          $sh (IN): location of the shell script to stage
    #          @arg (IN): arguments to pass, use empty array for none
    #          $timeout (opt. IN): time out
    # globals: %timeout (IN): determines default timeout
    # returns: hash ( job manager => [ status, wait-status ] )
    my $site = shift;
    my $good = shift;
    croak "FATAL: not a hashref" unless ref($good) eq 'HASH';
    my $sh = File::Spec->catfile( $pegasushome, 'libexec', 'pegasus-check-helper.2' );
    my $timeout = shift || $timeout{'run_batchjm'};

    my @jm = grep { $good->{$_->[0]}->[1] == 0 }
             $sc->contact( $site, 'vanilla' );
    warn "# submit_staged_batchjm $site\n";

    # add kickstart location on remote site
    my %seen = ();
    my @apps = ();
    push( @apps, $sc->gridshell($site) );
    $seen{$apps[0]} = 1;

    # create temporary file for application names
    my ($fd,$fn) = File::Temp::tempfile( 'chk-XXXXXX', UNLINK => 0, 
                                         DIR => File::Spec->tmpdir() );
    $main::unlink{$fn} = $main::parent;

    # add all other locations on remote site
    foreach my $tr ( $tc->dump_site($site) ) {
	my @x = $tc->resolve( $site, $tr );
	if ( @x > 0 ) {
	    unless ( exists $seen{$x[0]} ) {
		push( @apps, $x[0] );
		print $fd "$x[0]\n";
	    }
	    ++$seen{$x[0]};
	}
    }
    close $fd;

    # create arguments
    my @argv = ( '-x', '(jobType=single)', '-m', (2+($timeout / 60)) );
    my %env = $sc->profile( $site, 'env' );
    foreach my $key ( keys %env ) {
	push( @argv, '-env', "$key=$env{$key}" );
    }
    my %globus = $sc->profile( $site, 'globus' );
    foreach my $key ( keys %globus ) {
	push( @argv, '-x', "($key=$globus{$key})" );
    }
    push( @argv, '-stdin', '-s', $fn );
    my $script = File::Spec->canonpath(File::Spec->rel2abs($sh));
    push( @argv, '-s', $script );

    my %result = ();
    my $start = time();
    foreach my $jm ( map { $_->[0] } @jm ) {
	report( $start, "attempting to submit to $jm" );
	my @x = pipe_out_cmd( $timeout, $gjr, $jm, @argv );
	my $rc = $main::term ? -1 : $?;
	my $status = $main::term ? 'TIMEOUT' : ( $rc == 0 ? 'OK' : 'FAILED' );
	report( $start, "staged script on $jm \"$status\"" );
	$result{$jm} = [ $status, $rc ];
	deal_with_error( @x ) if $rc != 0;
    }
    
    delete $main::unlink{$fn} if unlink($fn);
    %result;
}

#
# --- main ------------------------------------------------------
#

# create catalog handles
my $wf = GriPhyN::WF->new('/dev/null') || die; # handle for wf conf module
$sc = load_module( $wf, { style => $scstyle, file => $scfn }, 'GriPhyN::SC' );
$tc = load_module( $wf, { style => $tcstyle, file => $tcfn }, 'GriPhyN::TC' );

# jet over all grids
my @grid = $sc->sites();
print "# found ", @grid+0, " grid sites.\n";

my $bar = '=' x 65;
my %summary = ();
syswrite( STDERR, "\n" );
foreach my $grid ( @grid ) {
    next if $grid eq 'local';	# skip local

    # say hi nicely
    syswrite( STDERR, "\n$bar\n\t$grid\n$bar\n" );
    my $intensity = $intense{$intense}[0]; # substr(lc($intense),0,1);

    # gatekeeper ping test
    my %jmgr = ping_gatekeeper( $grid );
    my @jmgr = grep { $jmgr{$_} eq 'OK' } keys %jmgr;
    my $minjm = ( grep { /-mis$/ } @jmgr ) ? 3 : 2;

    # gridftp server ping test
    my %gftp = ping_gridftp( $grid );
    my @gftp = grep { $gftp{$_} eq 'OK' } keys %gftp;

    # authentication tests
    if ( $intensity > $intense{ping}[0] ) {
	# jobmanagers authentication tests
	if ( @jmgr == 0 ) {
	    syswrite( STDERR, "WARNING: Skipping authentication tests (no contactable gatekeepers found)!\n" );
	} else {
	    # do it in two stages
	    my %fork = auth_forkjm( $grid, %jmgr );
	    my @fork = grep { $fork{$_}[1] == 0 } keys %fork;

	    my %batch = ();
	    if ( @fork == 0 && $force_batch == 0 ) {
		syswrite( STDERR, "WARNING: Skipping batch jobmanager authentication test, because\n\t the fork jobmanager authentication test alreaday failed!\n" );
	    } else {
		%batch = auth_batchjm( $grid, %jmgr );
	    }

	    %jmgr = ( %fork, %batch );
	    @jmgr = grep { $jmgr{$_}[1] == 0 } keys %jmgr;
	}

	# gridftp servers authentication tests
	if ( @gftp == 0 ) {
	    syswrite( STDERR, "WARNING: Skipping gridftp authentication tests (no contactable gridftp servers)!\n" );
	} else {
	    %gftp = auth_gridftp( $grid, %gftp );
	    @gftp = grep { $gftp{$_}[1] == 0 } keys %gftp;
	}
    }

    # file transfer test
    my $fn = undef;
    if ( $intensity > $intense{light}[0] ) {
	$fn = create_temporary_content;
	if ( @gftp == 0 ) {
	    syswrite( STDERR, "WARNING: Skipping transfer test (no contactable gridftp server)!\n" );
	} else {
	    %gftp = xfer_file( $grid, %gftp, $fn );
	    @gftp = grep { $gftp{$_}[1] == 0 } keys %gftp;
	}
    }

    # actual job tests
    if ( $intensity <= $intense{light}[0] ) {
	# ping and light intensity - done
    } elsif ( $intensity == $intense{medium}[0] ) {
	# medium intensity - remove staged file
	if ( @jmgr == 0 ) { 
	    syswrite( STDERR, "INFO: Skipping jobmanager tests!\n" );
	} else {
	    # only fork jm(s) are returned, but not batch jm(s)
	    my %x = simple_staged_forkjm( $grid, %jmgr, $fn );
	    foreach my $site ( keys %x ) {
		$jmgr{$site} = $x{$site}; # copy to dst
	    }
	    @jmgr = grep { $jmgr{$_}[1] == 0 } keys %jmgr;
	}
    } elsif ( $intensity == $intense{deep}[0] ) {
	# strong checking - check app paths on WN
	if ( @jmgr == 0 ) { 
	    syswrite( STDERR, "INFO: Skipping jobmanager tests!\n" );
	} else {
	    %jmgr = ( simple_staged_forkjm( $grid, %jmgr, $fn ),
		      submit_staged_batchjm( $grid, %jmgr ) );
	    @jmgr = grep { $jmgr{$_}[1] == 0 } keys %jmgr;
	}
    } else {
	# illegal code path
	die "ERROR: Illegal code path (intensity=$intense)";
    }

    # local clean-up
    unlink $fn if defined $fn;
    $!=0;			# undo errors

    # ok, what to do about the site
    if ( @gftp == 0 ) {
	# remove because no sane gridftp server found
	my $reason = @jmgr < $minjm ? 'jmgrs+gftp' : 'gridftp';
	if ( exists $main::status{$grid} ) {
	    $reason = 'authentication' if extra_check( $grid );
	}
	$summary{$grid} = [ 1, $reason ];
	syswrite( STDERR, "ATTENTION: removing $grid due to $reason\n\n" );
	$sc->delete($grid);
    } elsif ( @jmgr < 2 ) {
	# remove because no sane jobmanager set found
	my $reason = 'jobmanager'; 
	if ( exists $main::status{$grid} ) {
	    $reason = 'user cert auth' if extra_check( $grid );
	}
	$summary{$grid} = [ 1, $reason ];
	syswrite( STDERR, "ATTENTION: removing $grid due to jobmanagers\n\n" );
	$sc->delete($grid);
    } else {
	$summary{$grid} = [ 0 ];
	syswrite( STDERR, "ATTENTION: keeping $grid\n\n" );
    }
}

# dump catalogs
warn "# dumping catalogs...\n";
#local(*SC,*TC);
local(*SC);

open_with_backup( SC, $scfn ) || die "open $scfn: $!\n";
warn "# dumping SC into $scfn...\n";
$sc->show( \*SC );
close SC;

# FIXME: Once deep checking works, we'll need to update our TC
#open_with_backup( TC, $tcfn ) || die "open $tcfn: $!\n";
#warn "# dumping TC into $tcfn...\n";
#$tc->show( \*TC );
#close TC;

# summary
my @summary = sort keys %summary;
if ( scalar @summary ) {
    # determine site width
    my $width = 0;
    foreach my $site ( @summary ) {
	my $x = length($site);
	$width=$x if $x > $width;
    }

    # show sites
    print "\n\nSUMMARY:\n";
    foreach my $grid ( @summary ) {
	printf ' %*s', -$width, $grid;
	if ( $summary{$grid}[0] > 0 ) {
	    # bad site
	    printf " BAD: %-14s", $summary{$grid}[1];
#	    if ( exists $main::status{$grid} ) {
#		foreach my $what ( sort keys %{$main::status{$grid}} ) {
#		    printf " %s=%s", $what, $main::status{$grid}{$what};
#		}
#	    }
	} else {
	    print " OK";
	}
	print "\n";
    }
    print "\n";
}
