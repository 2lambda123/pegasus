#!/usr/bin/env python

"""
Pegasus utility for removing of files during workflow enactment

Usage: pegasus-cleanup [options]

"""

##
#  Copyright 2007-2011 University Of Southern California
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing,
#  software distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
##

import os
import re
import sys
import errno
import logging
import optparse
import tempfile
import subprocess
import signal
import string
import stat
import time
from collections import deque


__author__ = "Mats Rynge <rynge@isi.edu>"

# --- regular expressions -------------------------------------------------------------

re_parse_url = re.compile(r'([\w]+)://([\w\.\-:@]*)(/[\S]*)')

# --- classes -------------------------------------------------------------------------

class URL:

    proto      = ""
    host       = ""
    path       = ""
    # Only used with Policy Service
    id         = ""
    properties = {}

    def set_url(self, url):
        logger.debug("set_url using '" + url + "'")
        self.proto, self.host, self.path = self.parse_url(url)
    
    def parse_url(self, url):

        proto = ""
        host  = ""
        path  = ""

        # default protocol is file://
        if string.find(url, ":") == -1:
            logger.debug("URL without protocol (" + url + ") - assuming file://")
            url = "file://" + os.path.abspath(url) # assume we're the file source

        # file url is a special cases as it can contain relative paths and env vars
        if string.find(url, "file:") == 0:
            proto = "file"
            # file urls can either start with file://[\w]*/ or file: (no //)
            path = re.sub("^file:(//[\w\.\-:@]*)?", "", url)
            path = os.path.abspath(expand_env_vars(path))
            return proto, host, path

        # other than file urls
        r = re_parse_url.search(url)
        if not r:
            raise RuntimeError("Unable to parse URL: %s" % (url))
        
        # Parse successful
        proto = r.group(1)
        host = r.group(2)
        path = r.group(3)
        
        # no double slashes in urls
        path = re.sub('//+', '/', path)
        
        return proto, host, path

    def url(self):
        return "%s://%s%s" % (self.proto, self.host, self.path)
    
    def url_dirname(self):
        dn = os.path.dirname(self.path)
        return "%s://%s%s" % (self.proto, self.host, dn)

    def set_id(self, id):
        self.id = id
        return self.id
    
    def set_properties(self, properties):
        self.properties = properties

class Alarm(Exception):
    pass


# --- global variables ----------------------------------------------------------------

prog_base = os.path.split(sys.argv[0])[1]   # Name of this program

logger = logging.getLogger("my_logger")

# this is the map of what tool to use for a given protocol pair (src, dest)
tool_map = {}
tool_map['file'  ] = 'rm'
tool_map['ftp'   ] = 'gsiftp'
tool_map['gsiftp'] = 'gsiftp'
tool_map['irods' ] = 'irods'
tool_map['s3'    ] = 's3'
tool_map['s3s'   ] = 's3'
tool_map['scp'   ] = 'scp'
tool_map['srm'   ] = 'srm'

tool_info = {}

# This flag used to control calls to code that uses an external Policy Service.
# If the runtime environment sets a variable PEGASUS_POLICY_CHECKS, the flag is
# toggled and functions to submit the transfer list to the policy service are
# used. Otherwise, the list is just sorted lexically.
using_policy_service = False 


# --- functions -----------------------------------------------------------------------


def setup_logger(level_str):
    
    # log to the console
    console = logging.StreamHandler()
    
    # default log level - make logger/console match
    logger.setLevel(logging.INFO)
    console.setLevel(logging.INFO)

    # level - from the command line
    level_str = level_str.lower()
    if level_str == "debug":
        logger.setLevel(logging.DEBUG)
        console.setLevel(logging.DEBUG)
    if level_str == "warning":
        logger.setLevel(logging.WARNING)
        console.setLevel(logging.WARNING)
    if level_str == "error":
        logger.setLevel(logging.ERROR)
        console.setLevel(logging.ERROR)

    # formatter
    formatter = logging.Formatter("%(asctime)s %(levelname)7s:  %(message)s")
    console.setFormatter(formatter)
    logger.addHandler(console)
    logger.debug("Logger has been configured")


def prog_sigint_handler(signum, frame):
    logger.warn("Exiting due to signal %d" % (signum))
    myexit(1)


def alarm_handler(signum, frame):
    raise Alarm


def expand_env_vars(s):
    re_env_var = re.compile(r'\${?([a-zA-Z0-9_]+)}?')
    s = re.sub(re_env_var, get_env_var, s)
    return s


def get_env_var(match):
    name = match.group(1)
    value = ""
    logger.debug("Looking up " + name)
    if name in os.environ:
        value = os.environ[name]
    return value


def myexec(cmd_line, timeout_secs, should_log):
    """
    executes shell commands with the ability to time out if the command hangs
    """
    global delay_exit_code
    if should_log or logger.isEnabledFor(logging.DEBUG):
        logger.info(cmd_line)
    sys.stdout.flush()

    # set up signal handler for timeout
    signal.signal(signal.SIGALRM, alarm_handler)
    signal.alarm(timeout_secs)

    p = subprocess.Popen(cmd_line + " 2>&1", shell=True)
    try:
        stdoutdata, stderrdata = p.communicate()
    except Alarm:
        if sys.version_info >= (2, 6):
            p.terminate()
        raise RuntimeError("Command '%s' timed out after %s seconds" % (cmd_line, timeout_secs))
    rc = p.returncode
    if rc != 0:
        raise RuntimeError("Command '%s' failed with error code %s" % (cmd_line, rc))
    return rc

def backticks(cmd_line):
    """
    what would a python program be without some perl love?
    """
    return subprocess.Popen(cmd_line, shell=True, stdout=subprocess.PIPE).communicate()[0]


def check_tool(executable, version_arg, version_regex):
    # initialize the global tool info for this executable
    tool_info[executable] = {}
    tool_info[executable]['full_path'] = None
    tool_info[executable]['version'] = None
    tool_info[executable]['version_major'] = None
    tool_info[executable]['version_minor'] = None
    tool_info[executable]['version_patch'] = None

    # figure out the full path to the executable
    full_path = backticks("which " + executable + " 2>/dev/null") 
    full_path = full_path.rstrip('\n')
    if full_path == "":
        logger.info("Command '%s' not found in the current environment" %(executable))
        return
    tool_info[executable]['full_path'] = full_path

    # version
    if version_regex == None:
        version = "N/A"
    else:
        version = backticks(executable + " " + version_arg + " 2>&1")
        version = version.replace('\n', "")
        re_version = re.compile(version_regex)
        result = re_version.search(version)
        if result:
            version = result.group(1)
        tool_info[executable]['version'] = version

    # if possible, break up version into major, minor, patch
    re_version = re.compile("([0-9]+)\.([0-9]+)(\.([0-9]+)){0,1}")
    result = re_version.search(version)
    if result:
        tool_info[executable]['version_major'] = int(result.group(1))
        tool_info[executable]['version_minor'] = int(result.group(2))
        tool_info[executable]['version_patch'] = result.group(4)
    if tool_info[executable]['version_patch'] == None or tool_info[executable]['version_patch'] == "":
        tool_info[executable]['version_patch'] = None
    else:
        tool_info[executable]['version_patch'] = int(tool_info[executable]['version_patch'])

    logger.info("  %-18s Version: %-7s Path: %s" % (executable, version, full_path))


def check_env_and_tools():
    
    # PATH setup
    path = "/usr/bin:/bin"
    if "PATH" in os.environ:
        path = os.environ['PATH']
    path_entries = path.split(':')
    
    # is /usr/bin in the path?
    if not("/usr/bin" in path_entries):
        path_entries.append("/usr/bin")
        path_entries.append("/bin")
       
    # need LD_LIBRARY_PATH for Globus tools
    ld_library_path = ""
    if "LD_LIBRARY_PATH" in os.environ:
        ld_library_path = os.environ['LD_LIBRARY_PATH']
    ld_library_path_entries = ld_library_path.split(':')
    
    # if PEGASUS_HOME is set, prepend it to the PATH (we want it early to override other cruft)
    if "PEGASUS_HOME" in os.environ:
        try:
            path_entries.remove(os.environ['PEGASUS_HOME'] + "/bin")
        except Exception:
            pass
        path_entries.insert(0, os.environ['PEGASUS_HOME'] + "/bin")
    
    # if GLOBUS_LOCATION is set, prepend it to the PATH and LD_LIBRARY_PATH 
    # (we want it early to override other cruft)
    if "GLOBUS_LOCATION" in os.environ:
        try:
            path_entries.remove(os.environ['GLOBUS_LOCATION'] + "/bin")
        except Exception:
            pass
        path_entries.insert(0, os.environ['GLOBUS_LOCATION'] + "/bin")
        try:
            ld_library_path_entries.remove(os.environ['GLOBUS_LOCATION'] + "/lib")
        except Exception:
            pass
        ld_library_path_entries.insert(0, os.environ['GLOBUS_LOCATION'] + "/lib")

    os.environ['PATH'] = ":".join(path_entries)
    os.environ['LD_LIBRARY_PATH'] = ":".join(ld_library_path_entries)
    os.environ['DYLD_LIBRARY_PATH'] = ":".join(ld_library_path_entries)
    logger.info("PATH=" + os.environ['PATH'])
    logger.info("LD_LIBRARY_PATH=" + os.environ['LD_LIBRARY_PATH'])
    
    # irods requires a password hash file
    os.environ['irodsAuthFileName'] = os.getcwd() + "/.irodsA"
    
    # tools we might need later
    check_tool("globus-url-copy", "-version", "([0-9]+\.[0-9]+)")
    check_tool("srm-rm", "-version", "srm-copy[ \t]+([\.0-9a-zA-Z]+)")
    check_tool("irm", "-h", "Version[ \t]+([\.0-9a-zA-Z]+)")
    check_tool("pegasus-s3", "help", None)


def rm(url):
    """
    removes locally using /bin/rm
    """
    cmd = "/bin/rm -f \"%s\"" % (url.path)
    try:
        rc = myexec(cmd, 60, True)
    except RuntimeError, err:
        logger.error(err)
    return rc

def scp(url):
    """
    removes using ssh+rm
    """
    cmd = "/usr/bin/ssh -q  -o StrictHostKeyChecking=no" + \
          " " + url.host + " " + \
          " \"/bin/rm -f " + url.path + "\""
    try:
       rc = myexec(cmd, 60, True)
    except RuntimeError, err:
        logger.error(err)
    return rc

def gsiftp(url):
    """
    remove files on gridftp servers
    """
 
    if tool_info['globus-url-copy']['full_path'] == None:
        raise RuntimeError("Unable to do gsiftp rm becuase globus-url-copy could not be found")
   
    # build command line for globus-url-copy
    cmd = tool_info['globus-url-copy']['full_path']

    # make output from guc match our current log level
    if logger.isEnabledFor(logging.DEBUG):
        cmd += " -dbg"

    cmd += " -create-dest"
    cmd += " -no-third-party-transfers -no-data-channel-authentication"
    cmd += " file:///dev/null " + url.url()

    try:
        rc = myexec(cmd, 60, True)
    except RuntimeError, err:
        logger.error(err)
    return rc

def irods_login():
    """
    log in to irods by using the iinit command - if the file already exists,
    we are already logged in
    """
    f = os.environ['irodsAuthFileName']
    if os.path.exists(f):
        return
    
    # read password from env file
    if not "irodsEnvFile" in os.environ:
        raise RuntimeError("Missing irodsEnvFile - unable to do irods transfers")
    password = None
    h = open(os.environ['irodsEnvFile'], 'r')
    for line in h:
        items = line.split(" ", 2)
        if items[0].lower() == "irodspassword":
            password = items[1].strip(" \t'\"\r\n")
    h.close()
    if password == None:
        raise RuntimeError("No irodsPassword specified in irods env file")
    
    h = open(".irodsAc", "w")
    h.write(password + "\n")
    h.close()
    
    cmd = "cat .irodsAc | iinit"
    myexec(cmd, 60*60, True)
        
    os.unlink(".irodsAc")


def irods(url):
    """
    irods - use the icommands to interact with irods
    """

    if tool_info['irm']['full_path'] == None:
        raise RuntimeError("Unable to do irods transfers becuase iget could not be found in the current path")

    # log in to irods
    try:
        irods_login()
    except Exception, loginErr:
        logger.error(loginErr)
        raise RuntimError("Unable to log into irods")

    cmd = "irm -f " + url.path

    try:
        rc = myexec(cmd, 60, True)
    except Exception, err:
        logger.error(err)
    return rc


def srm(url):
    """
    srm - use srm-rm
    """

    if tool_info['srm-rm']['full_path'] == None:
        raise RuntimeError("Unable to do srm remove becuase srm-rm could not be found")

    cmd = "srm-rm " + url.url()
        
    try:
       rc = myexec(cmd, 60, True)
    except Exception, err:
        logger.error(err)
    return rc

def s3(url):
    """
    s3 - uses pegasus-s3 to interact with Amazon S3 
    """

    if tool_info['pegasus-s3']['full_path'] == None:
        raise RuntimeError("Unable to do S3 transfers becuase pegasus-s3 could not be found")

    cmd = "pegasus-s3 rm " + url.url()

    try:
        rc = myexec(cmd, 60, True)
    except Exception, err:
        logger.error(err)
    return rc

def remove(url):
    """
    removes the file with the given url
    """
    try:
        if tool_map.has_key(url.proto):
            tool = tool_map[url.proto]
            if tool == "rm":
                rc = rm(url)
            elif tool == "scp":
                rc = scp(url)
            elif tool == "gsiftp":
                rc = gsiftp(url)
            elif tool == "irods":
                rc = irods(url)
            elif tool == "srm":
                rc = srm(url)
            elif tool == "s3":
                rc = s3(url)
            else:
                logger.critical("Error: No mapping for the tool '%s'" %(tool))
                myexit(1)
        else:
            logger.critical("Error: This tool does not know how to remove from %s://" % (url.proto))
            myexit(1)

    except RuntimeError, err:
        logger.critical(err)
        myexit(1)
    return rc

def myexit(rc):
    """
    system exit without a stack trace - silly python
    """
    try:
        sys.exit(rc)
    except SystemExit:
        sys.exit(rc)

def post_cleanup_requests(inputs):
    """
    Format a request to the policy web service with the input URL objects.
    @param inputs: List of URL objects to process
    @type inputs: list
    @return: List of URL objects as modified by the web service.
    @rtype: list
    """
    if not using_policy_service or len(inputs) == 0:
        return None
    logger.debug("post_cleanup_requests entered; input list has %d URLs", len(inputs))
    hostname = getfqdn()
    cleanups = []
    for t in inputs:
        logger.debug("Processing input URL object: url=%s" %(t.url()))
        cleanup = {'uri' : t.url(), 'properties' : {} }
        if t.proto == 'file':
            cleanup['properties']['local_file_host'] = hostname
        cleanups.append(cleanup)

    policy_requests = json.dumps(cleanups)
    policy_headers = {'Content-type' : 'application/json', 'Encoding' : 'latin-1'}
    try:
        ws = HTTPConnection(policy_host, policy_port)
        logger.debug("Sending POST to URL %s:\n%s\n%s"%(policy_url,policy_requests,policy_headers))
        ws.request('POST', policy_url, policy_requests, policy_headers)
        resp = ws.getresponse();
        # Check for the HTTP Success response code.
        if resp.status != OK:
            logger.critical("HTTP protocol error from service: %d Full text: %s" %(resp.status, resp.read()))
            raise RuntimeError("HTTP protocol error from service: %d Reason: %s" %(resp.status, resp.reason))
        logger.info("policy web service status: %d", resp.status)
        resp_string = resp.read()
        ws.close()
        ws = None
    except HTTPException, e:
        logger.exception("HTTPException communicating with policy web service:")
        raise RuntimeError("HTTPException communicating with policy web service.")
    except SocketError, (value, message):
        logger.critical("socket exception: [ERRNO%s] %s", value, message)
        raise RuntimeError("socket exception: [ERRNO%s] %s" %(value, message))

    logger.debug("policy web service response: %s", resp_string)

    posted_cleanups = json.loads(resp_string)

    inputs = []; # wipe out old list
    for pc in posted_cleanups:
        logger.debug("url = %s  properties = {%s} id = %s",
                      pc['uri'], pc['properties'], pc['id'])
        cleanup = URL();
        cleanup.set_url(pc['uri'])
        cleanup.set_id(pc['id'])
        cleanup.set_properties(pc['properties'])
        logger.debug("appending cleanup id %s for url %s" %(cleanup.id,cleanup.url()))
        inputs.append(cleanup)

    logger.debug("post_cleanup_requests return")
    return inputs

def close_cleanup_requests(inputs):
    """
    Send a PUT request to the policy web service to notify it that the cleanups
    have been processed.
    @param inputs: A list of URL objects to process.
    @type inputs: list
    @return: Nothing.
    """
    if not using_policy_service or len(inputs) == 0:
        return

    logger.debug("close_cleanup_requests enter; input list has %d URLs",
                 len(inputs))

    cleanups = []
    for u in inputs:
        logger.debug("Processing URL object: url= %s" % (u.url()))
        cleanup = {'uri': u.url(), 'id': u.id, 'properties': {}}
        for p in u.properties.keys():
            cleanup['properties'][p] = u.properties[p]
        cleanups.append(cleanup)
    
    policy_cleanups = json.dumps(cleanups)
    logger.debug("policy_cleanups=%s"%(policy_cleanups))
    policy_headers = {'Content-type' : 'application/json', 'Encoding' : 'latin-1'}
    try: 
        ws = HTTPConnection(policy_host, policy_port)
        logger.debug("Sending PUT to URL %s" %(policy_url))
        ws.request('PUT', policy_url, policy_cleanups, policy_headers)
        # TODO What if the server is slow and not ready to respond? httplib
        # throws a ResponseNotReady exception, which in 2.6 doesn't have any
        # useful text assigned to the exception message.
        resp = ws.getresponse();
        if resp.status != OK:
            logger.critical("HTTP protocol error from service: %d Full text: %s" %(resp.status, resp.read()))
            raise RuntimeError("HTTP protocol error from service: %d Reason: %s" %(resp.status, resp.reason))

        logger.debug("status for PUT: %d" %(resp.status))

        ws.close()
        ws = None
    except HTTPException, e:
        # These exceptions (on 2.6) don't appear to have anything in them. 
        logger.exception("HTTPException communicating with policy web service:")
        raise RuntimeError("HTTPException communicating with policy web service.")
    except SocketError, (value, message):
        logger.critical("socket exception: [ERRNO%s] %s", value, message)
        raise RuntimeError("socket exception: [ERRNO%s] %s" %(value, message))

    logger.debug("close_cleanup_requests exit")

# --- main ----------------------------------------------------------------------------

# dup stderr onto stdout
sys.stderr = sys.stdout

# Configure command line option parser
prog_usage = "usage: %s [options]" % (prog_base)
parser = optparse.OptionParser(usage=prog_usage)
parser.add_option("-l", "--loglevel", action = "store", dest = "log_level",
                  help = "Log level. Valid levels are: debug,info,warning,error, Default is info.")
parser.add_option("-f", "--file", action = "store", dest = "file",
                  help = "File containing URLs to be removed. If not given, list is read from stdin.")
# Check environment to decide whether to use a Policy Service.
if 'PEGASUS_POLICY_CHECKS' in os.environ:
    true_synonyms = ('true', '1', 't', 'y', 'yes', 'on', 'enabled', 'enable')
    using_policy_service = os.environ['PEGASUS_POLICY_CHECKS'].lower() in true_synonyms
    
if using_policy_service:
    logger.info("Attempting to use Policy Service for cleanups.")
    # Extra imports to make policy service work. If not available, fail now
    try:
        import json
    except ImportError:
        print >>sys.stderr, "Cannot use Policy Check: Failed to import JSON library"
        myexit(1)

    try:
        from httplib import HTTPConnection, HTTPException, OK
    except ImportError:
        print >>sys.stderr, "Cannot use Policy Check: Failed to import HTTP library"
        myexit(1)
        
    from socket import error as SocketError
    from socket import getfqdn
    
    policy_host = "localhost"
    policy_port = 80
    policy_url_root = "/policy/"
    policy_service = "cleanup/list/"
    policy_url  = policy_url_root + policy_service

    parser.add_option("", "--policy-host", action = "store", dest = "policy_host",
                      help = "hostname for the Policy web service; default is '%s'" %(policy_host))
    parser.add_option("", "--policy-port", type="int", dest = "policy_port",
                      help = ("Port used by the policy web service; default is %d" %(policy_port)))
    parser.add_option("", "--policy-url", dest = "policy_url",
                      help = ("URL of the policy web service; default is '%s'" %(policy_url)))

    if 'PEGASUS_POLICY_HOST' in os.environ:
        policy_host = os.environ['PEGASUS_POLICY_HOST']
        
    if 'PEGASUS_POLICY_PORT' in os.environ:
        policy_port = int(os.environ['PEGASUS_POLICY_PORT'])
        
    if 'PEGASUS_POLICY_URL' in os.environ:
        policy_url_root = os.environ['PEGASUS_POLICY_URL']
        policy_url  = policy_url_root + policy_service

# Parse command line options
(options, args) = parser.parse_args()
if options.log_level == None:
    options.log_level = "info"
setup_logger(options.log_level)

# If we're using a Policy Service, check the command line for environment
# overrides.
if using_policy_service:
    if options.policy_host != None:
        policy_host = options.policy_host.strip()
    if options.policy_port != None:
        policy_port = options.policy_port
    if options.policy_url != None:
        policy_url = options.policy_url.strip()
    # ensure URL ends in a slash.
    if  not policy_url.endswith("/"):
        logger.debug("Appending '/' to policy_url.")
        policy_url = policy_url + "/"
    logger.debug("policy service at http://%s:%d%s"%(policy_host, policy_port, policy_url))

# Die nicely when asked to (Ctrl+C, system shutdown)
signal.signal(signal.SIGINT, prog_sigint_handler)

# stdin or file input?
if options.file == None:
    logger.info("Reading URLs from stdin")
    input_file = sys.stdin
else:
    logger.info("Reading URLs from %s" % (options.file))
    try:
        input_file = open(options.file, 'r')
    except Exception, err:
        logger.critical('Error reading url pair list: %s' % (err))
        myexit(1)

# check environment and tools
try:
    check_env_and_tools()
except Exception, err:
    logger.critical(err)
    myexit(1)

# fill the url queue with user provided entries
line_nr = 0
input_urls = []
try:
    for line in input_file.readlines():
        line_nr += 1
        if line[0] != '#' and len(line) > 4:
            line = line.rstrip('\n')
            url = URL()
            url.set_url(line)
            #remove(url) Don't do it yet...
            input_urls.append(url)

    if using_policy_service:
        logger.info("cleanups: Using policy web service at %s on port %d with URL %s",
                    policy_host, policy_port, policy_url)
        input_urls = post_cleanup_requests(input_urls)

    # queues to track the work
    url_q = deque(input_urls)
    while url_q:
        next_url = url_q.pop()
        rc = remove(next_url)
        if rc == 0:
            next_url.properties['STATUS'] = 'COMPLETED'
        else:
            next_url.properties['STATUS'] = 'FAILED'

    close_cleanup_requests(input_urls) # returns immediately if not using policy

except Exception, err:
    logger.critical('Error handling url: %s' % (err))
    myexit(1)

myexit(0)


