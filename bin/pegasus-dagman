#!/usr/bin/env python

"""
pegasus-dagman

This program is to be run as a replacement for condor_dagman inside
of a submit file. The dag can be submitted by running the command
condor_submit_dag -dagman /path/to/pegasus-dagman my.dag

Usage: pegasus-dagman [options] 
"""

##
#  Copyright 2007-2010 University Of Southern California
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing,
#  software distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
##
# Author : gmehta at isi dot edu
# Revision : $Revision$
__author__ = "Gaurang Mehta"
__author__ = "Mats Rynge"

import os, sys, signal, subprocess
import logging
import time
import math
import shutil

# Use pegasus-config to find our lib path
bin_dir = os.path.normpath(os.path.join(os.path.dirname(sys.argv[0])))
pegasus_config = os.path.join(bin_dir, "pegasus-config")
lib_dir = subprocess.Popen([pegasus_config,"--noeoln","--python"], stdout=subprocess.PIPE, shell=False).communicate()[0]
lib_ext_dir = subprocess.Popen([pegasus_config,"--noeoln","--python-externals"], stdout=subprocess.PIPE, shell=False).communicate()[0]


# Insert this directory in our search path
os.sys.path.insert(0, lib_ext_dir)
os.sys.path.insert(0, lib_dir)

import Pegasus.common
from Pegasus.tools import utils

# logger is setup in common
logger = logging.getLogger()
logger.setLevel(logging.INFO)

SLEEP_TIME = 15
DIED_TOO_QUICKLY_TIME = 120

dagman = None
monitord = None

monitord_last_start = 0
monitord_next_start = 0
monitord_restarts = 0

def find_prog(name):
    PATH = os.getenv("PATH", "/bin:/usr/bin:/usr/local/bin")
    PATH = PATH.split(os.pathsep)
    PATH.insert(0, bin_dir)

    for path in PATH:
        exe = os.path.join(path, name)
        if os.path.isfile(exe) and os.access(exe, os.X_OK):
            return exe

    raise Exception("%s not found" % name)

def dagman_launch(dagman_bin):
    '''Launches the condor_dagman program with all
       the arguments passed to pegasus-dagman'''
    try:
        arguments = sys.argv[1:]
        arguments.insert(0, "condor_scheduniv_exec."+os.getenv("CONDOR_ID"))

        dagman_proc = subprocess.Popen(arguments,
                                       stdout=sys.stdout,
                                       stderr=sys.stderr,
                                       executable=dagman_bin)

        logger.info("Launched Dagman with pid %d" % dagman_proc.pid)

        return dagman_proc
    except OSError, err:
        logger.error("Could not launch Dagman",  err)
        sys.exit(1)

def monitord_launch(monitord_bin):
    '''Launches Monitord in condor foreground mode'''
    try:
        # PM-688: Rotate log file, if it exists
        logfile = "monitord.log"
        utils.rotate_log_file(logfile)
        log = open(logfile, 'a')

        dagman_log = os.getenv('_CONDOR_DAGMAN_LOG')

        monitord_proc = subprocess.Popen(
                    [monitord_bin, "-N", dagman_log],
                    stdout=log,
                    stderr=subprocess.STDOUT)

        logger.info("Launched monitord with pid %d" % monitord_proc.pid)

        log.close()

        return monitord_proc
    except OSError, err:
        logger.error("Could not launch monitord", err)
        return None

def is_dagman_copy_to_spool():
    '''Checks using condor_config_val if dagman_copy_to_spool is set
    then copy condor_dagman to the current dir "bin_dir" 
    '''
    condor_config_val = find_prog("condor_config_val")
    copy_to_spool = subprocess.Popen([condor_config_val,"DAGMAN_COPY_TO_SPOOL"], stdout=subprocess.PIPE, shell=False).communicate()[0]
    logger.info("DAGMAN_COPY_TO_SPOOL is set to %s" % copy_to_spool)
    return copy_to_spool.lower().strip() == "true"

def sighandler(signum, frame):
    ''' Signal handler to catch and pass SIGTERM, SIGABRT, SIGUSR1, SIGTERM '''
    print "pegasus-dagman caught SIGNAL", signum
    if dagman != None:
        os.kill(dagman.pid, signum)
    if monitord != None:
        if signum == signal.SIGUSR1:
            signum = signal.SIGINT
        os.kill(monitord.pid, signum)

if __name__ == "__main__":

    os.setpgid(0, 0)
    signal.signal(signal.SIGTERM, sighandler)
    signal.signal(signal.SIGINT, sighandler)
    signal.signal(signal.SIGABRT, sighandler)
    signal.signal(signal.SIGUSR1, sighandler)
    signal.signal(signal.SIGUSR2, sighandler)

    logger.info("Pegasus python lib: %s", lib_dir)
    logger.info("Pegasus external python lib: %s", lib_ext_dir)
    logger.info("Pegasus bin: %s", bin_dir)
    logger.info("pegasus-dagman: %s", sys.argv[0])

    dagman_bin = find_prog("condor_dagman")
    monitord_bin = find_prog("pegasus-monitord")

    # If copy_to_spool is set, copy dagman binary to dag submit directory
    copy_to_spool = is_dagman_copy_to_spool()
    if copy_to_spool:
        old_dagman_bin = dagman_bin
        dagman_bin = os.path.join(os.getcwd(), "condor_scheduniv_exec."+os.getenv("CONDOR_ID"))
        shutil.copy2(old_dagman_bin, dagman_bin)
        logger.info("Copied condor_dagman from %s to %s" % (old_dagman_bin, dagman_bin))

    dagman = dagman_launch(dagman_bin)
    monitord = monitord_launch(monitord_bin)

    while True:
        dagman.poll()
        monitord.poll()

        # If dagman exits, then just wait for monitord
        if dagman.returncode is not None:
            logger.info("DAGMan exited, waiting for monitord")
            monitord.wait()
            break

        # If dagman is running, and monitord is not, then we may need to restart it
        if monitord.returncode is not None:
            logger.warning("monitord exited")

            # XXX Why are we restarting monitord? If it fails, how can restarting help?
            now = time.time()
            if monitord_next_start == 0:

                # did the process die too quickly?
                if now - monitord_last_start < DIED_TOO_QUICKLY_TIME:
                    monitord_restarts += 1
                else:
                    monitord_restarts = 0

                # backoff with upper limit
                backoff = min(4**monitord_restarts, 3600)
                logger.info("Next monitord launch scheduled in about %d seconds" % (backoff))
                monitord_next_start = now + backoff - 1

            # time to restart yet?
            if monitord_next_start <= now:
                monitord_next_start = 0
                monitord_last_start = now
                monitord = monitord_launch(monitord_bin)

        # sleep in between polls
        time.sleep(SLEEP_TIME)

    logger.info("Dagman exited with code %d" % dagman.returncode)
    logger.info("Monitord exited with code %d" % monitord.returncode)

    if copy_to_spool:
        logger.info("Removing copied condor_dagman from submit directory %s" % dagman_bin)
        os.remove(dagman_bin)

    # Exit pegasus-dagman with a merged returncode
    # XXX Why are we doing this? Does the monitord return code matter?
    sys.exit(dagman.returncode & monitord.returncode)

