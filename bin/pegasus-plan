#!/usr/bin/env perl
#
# Wrapper around planners to give a uniform interface
#
# This file or a portion of this file is licensed under the terms of
# the Globus Toolkit Public License, found in file GTPL, or at
# http://www.globus.org/toolkit/download/license.html. This notice must
# appear in redistributions of this file, with or without modification.
#
# Redistributions of this Software, with or without modification, must
# reproduce the GTPL in: (1) the Software, or (2) the Documentation or
# some other similar material which is provided with the Software (if
# any).
#
# Copyright 1999-2004 University of Chicago and The University of
# Southern California. All rights reserved.
#
# Author: Jens-S. Vöckler voeckler@cs.uchicago.edu
# Revision : $Revision: 1.32 $
#
use 5.006;
use strict;
use File::Spec;
use File::Copy ();
use File::Basename qw(dirname basename);
use POSIX qw(strftime);
use Errno qw(:POSIX EEXIST);
use Getopt::Long qw(:config bundling no_ignore_case);
use XML::Parser::Expat;

# load our own local modules
use Work::Common;
use Work::Workflow; 
use Work::Properties qw(:parse %initial %system); # parses -Dp=v from CLI

$main::version = 'unknown';
$_ = '$Revision: 1.32 $';	# don't edit
$main::version = $1 if /Revision:\s+([0-9.]+)/o;

# constants
sub usage();			# { }
sub version();			# { }
    
my $sft;       			# if overwrite active
my $sftbase = 'grid3.sft';	# submit file template for d2d basename
$main::DEBUG = 0;		# default
my %config = ();

my ($pegasusrc,$wfrc,$pre,$post);	# if overwriting
my @planner = ( undef, 'gencdag' );
my $planner = 1;
my %forward = ();
my %options = ();

GetOptions( "help|h" => \&usage,
	    "version|V" => \&version,
#	    "template|t=s" => \$config{sft},
	    "base|dir|b=s" => \$config{basedir},
	    "sftbase|s=s" => \$sftbase,
#	    "wfrc|w=s" => \$wfrc,
	    "pegasusrc|pegasusrc=s" => \$pegasusrc,
	    "vogroup|g=s" => \$config{vogroup},
	    "forward|f=s" => \%forward,
	    "options|option|o=s" => sub {
		my ($k,$v) = split /=/, $_[1], 2;
		$options{$k} = $v; # will insert undef for flags
	    },
	    "prescript|pre=s" => \$pre,
	    "postscript|post=s" => \$post,
	    "pegasus|peg|p" => sub { $planner = 1 },
	    "debug|d=o" => \$main::DEBUG,
	    "verbose|v+" => \$main::DEBUG 
	    );

# check planner mandatory option
#die "FATAL: Use either --pegasus or --euryale\n\n"
#    unless ( $planner > 0 && $planner <= 2 );

# check location of wfrc now -- make user path absolute
#if ( defined $wfrc ) {
#    if ( -r $wfrc ) {
#	$wfrc=File::Spec->rel2abs($wfrc) if substr($wfrc,0,1) ne '/';
#    } else {
#	die "ERROR: Unreadable file in --wfrc=$wfrc\n";
#    }
#}
#print STDERR '# using wfrc location ', 
#    ( defined $wfrc ? $wfrc : 'default' ), "\n"
#    if ( $main::DEBUG );

# check location of pegasusrc now -- make user path absolute
if ( defined $pegasusrc ) {
    if ( -r $pegasusrc ) {
	$pegasusrc=File::Spec->rel2abs($pegasusrc) if substr($pegasusrc,0,1) ne '/';
    } else {
	die "ERROR: Unreadable file in --pegasusrc=$pegasusrc\n";
    }
}
print STDERR '# using pegasusrc location ', 
    ( defined $pegasusrc ? $pegasusrc : 'default' ), "\n"
    if ( $main::DEBUG );

my %extra = ();
#$extra{'wf.properties'} = $wfrc if defined $wfrc;
$extra{'pegasus.user.properties'} = $pegasusrc if defined $pegasusrc;
my $props = ( %extra == 0 ? Work::Properties->new() :
	      Work::Properties->new( PARSE_ALL, { %extra } ) );
$config{basedir} ||= $props->property('pegasus.base.dir') || 
    File::Spec->catdir( $system{'user.home'} || '.', 'run' );
$config{vogroup} ||= 
    $props->property('pegasus.profile.pegasus.vogroup') || # new
#    $props->property('pegasus.vo.group') || # old
    'pegasus';			# default
die( "ERROR: The VO group \"$config{vogroup}\" contains file separators.\n",
     "This is not permitted. Please fix and retry.\n" )
    if index($config{vogroup},'/') >= 0;

# arguments
if ( @ARGV == 2 ) {
    # old style invocation
    die "ERROR: Please use new-style invocation: -g vogroup daxfile\n";
}

# dax input file
my $daxfile = shift;
die "ERROR: You must specify a dax filename as argument\n"
    unless defined $daxfile && -e $daxfile;
die "ERROR: The $daxfile is not readable\n"
    unless -r _;
die "ERROR: The $daxfile is not a regular file\n"
    unless -f _;

#
# --- functions -------------------------------------------------
#

sub version() {
    my $basename = basename($0,'.pl');
    print "$basename $main::version\n";
    exit(0);
}

sub usage() {
    my $basename = basename($0,'.pl');
    print << "EOF";

Usage: $basename [options] daxfile

Mandatory arguments:
 daxfile            is the filename of the abstract workflow in XML.

Optional arguments:
 -Dprop=val         explicit settings of a pegasus-plan property (multi-option).
 -h|--help          print this help message and exit.
 -V|--version       display the version string and exit.
 -d|--debug lvl     sets the debug level (verbosity), default is $main::DEBUG. 
 -v|--verbose       raises debug level by 1, see --debug. 
 -b|--base dir      base directory for directory structure of workflows, 
                    defaults to pegasus.base.dir=\$HOME/run.
 -s|--sftbase sft   basename of an alternative submit file template from 
                    the Euryale distribution directory, default is $sftbase.
 -t|--template sft  full location of an alternative submit file template.
 -g|--vogroup g     uses the VO group g, default is wf.profile.vo.group=ivdgl1.
                    The VO group is a designator for policy management.
    --pegasusrc rcfile  property location of Pegasus user properties,
                    default location is pegasus.user.properties=\$HOME/.pegasusrc

Optional arguments for planners ([P]egasus, [E]uryale, [B]oth):
 -f|--forward k=v   [B] forward property to planner (multi-option).
 -o|--option k=v    [B] forward command-line option to planner (multi-option).
                        For flags, use "--option flag" without = nor value. 

EOF
    exit(1);
}

sub check($$) {
    # purpose: check for the existence of an option that clashes with
    #          command-line options the planner will overwrite. Warn.
    # paramtr: $optref (IN): array reference to options to check.
    #          $msg (IN): What to say, if any option was found
    # globals: %options (IO): command-line arguments passed to planner
    #          If an $optref member is found in %options, it will be removed.
    # returns: number of options removed, 0 or more. 
    my $optref = shift;
    die "FATAL: need an array reference" unless ref($optref) eq 'ARRAY';
    my $msg = shift;
    my $result = 0;

    foreach my $opt ( @{$optref} ) {
	if ( defined $opt && exists $options{$opt} ) {
	    print STDERR "# Ignoring user option $opt: $msg\n" if $main::DEBUG;
	    delete $options{$opt};
	    ++$result;
	}
    }

    $result;
}

#
# --- main ------------------------------------------------------
#

## sanity check: You must use umask 0002
#umask 0002;

# sanity check: There is a PEGASUS_HOME
$config{pegasushome} = $props->property('pegasus.home'); # set from environment
die( "ERROR: Unable to detect the location of environment variable PEGASUS_HOME\n")
    unless defined $config{pegasushome};
print STDERR "# PEGASUS_HOME=$config{pegasushome}\n" if $main::DEBUG;

# where is our gencdag|d2d planner? 
my $cplanner = $config{planner} =
    File::Spec->catfile( $config{pegasushome}, 'bin', $planner[$planner] );
die( "ERROR: Unable to find executable $cplanner\n" ) unless -x $cplanner;
print STDERR "# using $planner[$planner] from $cplanner\n" if $main::DEBUG;

# NEW: Sanity checks on executability of call-outs
my %pegasus = ();
my %euryale = ();
if ( $planner == 1 ) {
    # 
    # HERE: Extra early simple (!) sanity checks that certain things good.
    # propagate found values for later perusal in the %pegasus hash.
    #
} elsif ( $planner == 2 ) {
    # determine our true submit file template (sft)
    $config{sft}=File::Spec->catfile( $config{pegasushome}, 'share', $sftbase )
	unless defined $config{sft} && length($config{sft}) > 0;
    die( "ERROR: No submitfile template at $config{sft}\n" ) 
	unless ( -r $config{sft} && -f _ );
    print STDERR "# using sft file $config{sft}\n" if $main::DEBUG;

    my $sitesel = $euryale{sitesel} = $props->property('wf.site.selector');
    die( "ERROR: Your site selector is not executable, see wf.site.selector\n",
	 "in your $wfrc file.\n" )
	unless -x $sitesel;
    my $popman = $euryale{popman} = $props->property('wf.popularity.manager');
    die( "ERROR: Your popularity mgr is not executable, see wf.popularity.manager.\n",
	 "in your $wfrc file. If you don't use a popularity management,\n",
	 "set the property explicitely to the string \"null\" without the quotes.\n" )
	unless ( lc($popman) eq 'null' || -x $popman );
}

############
# EXTRACT THE LABEL FROM THE DAX FILE
############

my @stat = stat($daxfile);
open( DAX, "<$daxfile" ) || die "open $daxfile: $!\n";

# extract the label from the dax file's root element (and jobCount)
# Beware, there may be linefeeds between attributes - Karan's bug report
my $parser = new XML::Parser::Expat( 'Namespaces' => 1 );
$config{jobcount} = 0;
$parser->setHandlers( 'Start' => sub {
    my $self = shift;
    my $element = shift;	# name of element
    if ( $element eq 'adag' ) {
	my %attr = @_;		# attributes
	$config{label} = $attr{name};
    } elsif ( $element eq 'job' ) {
	$config{jobcount}++;
    }
} );
$parser->parse(*DAX);
close DAX;

die( "ERROR: The workflow does not specify a label!\n" )
    unless $config{label};
die( "ERROR: The workflow label \"$config{label}\" contains file separators!\n",
     "We suggest using a workflow label similar to a C or Java identifier.\n" )
    if index($config{label},'/') >= 0;
if ( $config{label} !~ m{[-_[:alnum:].]+} ) {
    $config{label} =~ tr/-A-Za-z0-9._/_/cs;
    warn( "Warning: Label \"$config{label}\" is not a good identifier\n",
	  "Folding unwanted characters into underscore: \"$config{label}\"\n" );
}
print STDERR "# workflow label $config{label}\n" if $main::DEBUG;

die( "ERROR: You workflow does not appear to contain any jobs!\n" )
    unless $config{jobcount};
print STDERR "# job count $config{jobcount}\n" if $main::DEBUG;

# DO nag, if the label has value "test"
if ( $config{label} eq 'test' ) {
    my $base = basename($daxfile,'.dax','.xml');
    my $msg = "Info: You use a workflow label of \"$config{label}\", how boring! " .
	"It makes distinguishing\nyour workflow from others difficult. " . 
	"Provenance becomes meaningless.";
    $msg .= " Even using the name\n\"" . basename($daxfile,'.dax') .
	"\" may help." if $base ne 'test';
    warn "\n$msg\n\n";
}

# remove trailing slashes
while ( length($config{basedir}) && substr($config{basedir},-1,1) eq '/' ) {
    warn "# removing trailing slash from basedir\n";
    substr( $config{basedir}, -1, 1, '' );
}

# my special testing premature exit. 
exit 42 if $main::DEBUG == 42;

# rel2abs for base directory
if ( substr($config{basedir}, 0, 1) ne '/' ) {
    print STDERR "# Warning: relative base directory ", $config{basedir}, "\n";
    $config{basedir} = File::Spec->rel2abs( $config{basedir} );
} else {
    print STDERR "# good, base directory is absolute\n"	if $main::DEBUG;
}

# sanity check: /home/work/workflows exists
if ( ! -d $config{basedir} ) {
    # does not exist, try to create
    mkdir($config{basedir}) || die( "ERROR: mkdir $config{basedir}: $!\n" );
    print STDERR "# created base directory $config{basedir}\n" if $main::DEBUG;
} else {
    print STDERR "# using base directory $config{basedir}\n" if $main::DEBUG;
}
# post-condition: $config{basedir} exists

# sanity check: /home/work/workflows/$vogroup exists
my $vofs = File::Spec->catfile( $config{basedir}, $config{vogroup} );
if ( ! -d $vofs ) {
    # does not exist, create
    mkdir($vofs) || die( "ERROR: mkdir $vofs: $!\n" );
    print STDERR "# created $vofs\n" if $main::DEBUG;
} else {
    print STDERR "# found $vofs\n" if $main::DEBUG;
}
# post-condition: $vofs exists

# sanity check: /home/work/workflows/$vogroup/$label exists
my $lbvofs = File::Spec->catfile( $vofs, $config{label} );
if ( ! -d $lbvofs ) {
    # does not exist, create
    mkdir($lbvofs) || die( "ERROR: mkdir $lbvofs: $!\n" );
    print STDERR "# created $lbvofs\n" if $main::DEBUG;
} else {
    print STDERR "# found $lbvofs\n" if $main::DEBUG;
}
# post-condition: $lbvofs exists

# which subdir to use for the next run
# FIXME: start of critical section
RETRY:
opendir( DIR, $lbvofs ) || die "ERROR: opendir $lbvofs: $!\n";
$_ = (sort { $b cmp $a } grep { /run\d{4,}/ } readdir(DIR))[0];
closedir( DIR );
if ( /run(\d{4,})/ ) {
    # other subdirs exist, chose next one
    $_ = sprintf( "run%04d", $1+1 );
} else {
    # we are the first
    $_ = 'run0001';
}
# FIXME: end of critical section
print STDERR "# using rundir basename $_\n" if $main::DEBUG;

# KARAN: Want to store just run basename in config
# JENS: Use $config{rundir}
#$config{rundirbase} = $_;

$config{run} = File::Spec->catfile( $lbvofs, $_ );
unless ( mkdir( $config{run} ) ) {
    # poor man's collision avoidance (atomic mkdir)
    goto RETRY if ( $!{EEXIST} );
    die( "ERROR: mkdir $config{run}: $!\n" );
}
# post-condition: $config{run} is a valid run-directory for the workflow
print "# created rundir $config{run}\n" if $main::DEBUG;
$config{rundir} = basename($config{run});

# copy dax to rundir -- so everything is in one place for debugging
$config{dax} = File::Spec->catfile( $config{run}, basename($daxfile) );
if ( $stat[7] < 1048576 ) {
    # copy small files < 1 MB
    die( "ERROR: Copying DAX to $config{dax}: $!\n" )
	unless File::Copy::copy( $daxfile, $config{dax} );
    print "# copied DAX into $config{dax}\n" if $main::DEBUG;

    # update atime and mtime of the DAX copy to match the original
    utime( $stat[8], $stat[9], $config{dax} );
} else {
    # symlink large files >= 1 MB
    # bugfix: for symlink, we must use the correct absolute source name
    my $absdax = File::Spec->rel2abs($daxfile);
    die( "ERROR: Linking $absdax -> $config{dax}: $!\n" )
	unless symlink( $absdax, $config{dax} ) == 1;
    print "# symlinked DAX into $config{dax}\n" if $main::DEBUG;
}

if ( $planner == 1 ) {
    # 
    # HERE: Any setups not handled by other stuff before. Do not call
    # gencdag (yet). You may use values from %pegasus set earlier.
    #
} elsif ( $planner == 2 ) {
    # Setup quickstart
    my $quickstart = $props->property('wf.quick.start');
    if ( defined $quickstart && length($quickstart) ) {
	print STDERR "# quickstart site selector enabled\n" if $main::DEBUG;

	# employ extra sanity checks for quickstart
	die( "ERROR: Your site selector does not appear to match the enabling of quickstart.\n",
	     "Please check your $wfrc for wf.site.selector.\n",
	     "It currently points to $euryale{sitesel}\n" )
	    unless ( index($euryale{sitesel},'quickstart') >= 0 );
	die( "ERROR: Your popularity mgr does not appear to match the enabling of quickstart.\n",
	     "Please check your $wfrc for wf.popularity.manager.\n",
	     "It currently points to $euryale{popman}\n" )
	    unless ( index($euryale{popman},'quickstart') >= 0 );
	
	# find the setup script
	my $setup = $props->property('wf.quick.setup') ||
	    find_exec( 'quickstart-setup', 1 ); # permit local
	die "ERROR: Unable to execute setup $setup!\n" unless -x $setup;
	print STDERR "# quickstart setup is $setup\n" if $main::DEBUG;

	# and run the setup
	my @args = ( $setup );
	push( @args, '--debug' ) if $main::DEBUG > 1;
	push( @args, '--wfrc', $wfrc ) if ( defined $wfrc && -r $wfrc );
	push( @args, '--dir', $config{run} );
	print STDERR "# ", join(' ',@args), "\n" if $main::DEBUG;
	system(@args) == 0 
	    or die( "ERROR: Running quickstart-setup failed: ", parse_exit($?) );
    }
} else {
    die "FATAL: Assertion failure: This branch should never be reached";
}

# prepare arguments for planner invocation
my @args = ( $cplanner );	

# propagate property overrides
push( @args, "-Dpegasus.user.properties=$pegasusrc" )
    if ( defined $pegasusrc && -r $pegasusrc );

# propagate the --forward arguments as properties
foreach my $fwd ( keys %forward ) { 
    push( @args, "-D$fwd=" . $forward{$fwd} );
}

# [B] check for --verbose|-v option and warn
check( [ 'v', 'verbose' ], 'debug level will be set by pegasus-plan' );
push( @args, '-' . ( 'v' x $main::DEBUG ) ) if $main::DEBUG > 0;

if ( $planner == 1 ) {
    # preparing the randomdir option
    $pegasus{randomdir} = File::Spec->catfile( $config{vogroup},
					       $system{'user.name'},
					       $config{label}, 
					       $config{rundir} );

    # [P] check for --dax|-d option and warn
    check( [ 'd', 'dax' ], 'dax option will be set by pegasus-plan' );
    push( @args, '--dax', $config{dax} );

    # [P] check for --dir|-D option and warn
    check( [ 'D', 'dir' ], 'submit directory option will be set by pegasus-plan' );
    push( @args, '--dir', $config{run} );

    # [P] if neither --randomdir|-r option is set, we will set one
    # if the option exists, the option passing code will set it. 
    unless ( exists $options{'randomdir'} || exists $options{'r'} ) {
	print STDERR "# Using remote random dir $pegasus{randomdir}\n"
	    if $main::DEBUG;
	push( @args, "--randomdir=$pegasus{randomdir}" );
    }

}


# propagate the --option planner command-line options
foreach my $opt ( keys %options ) {
    if ( length($opt) == 1 ) {
	# short option - use one hyphen
	push( @args, "-$opt" );
	push( @args, $options{$opt} ) if defined $options{$opt};
    } else {
	# long option -- use two dashes
	my $what = "--$opt";
	$what .= "=$options{$opt}" if defined $options{$opt};
	push( @args, $what ) if length($what) > 0;
    }
}

if ( $planner == 1 ) {
    #
    # HERE: Anything to do for Pegasus? Don't think so
    #
} else {
    # Ensure that the dax file is actually an argument, not an option
    push( @args, $config{dax} );
}

print STDERR "# ", join(' ',@args), "\n" if $main::DEBUG;
system(@args) == 0 
    or die( "ERROR: Running $planner[$planner] failed: ", parse_exit($?) );
$config{dag} = File::Spec->catfile( $config{run}, "$config{label}-0.dag" );
die "ERROR: The DAGMan .dag file was not created!\n" 
    unless ( -r $config{dag} );
print STDERR "# ran $planner[$planner] successfully\n" if $main::DEBUG;

# what is the job state db filename
$config{jsd} = File::Spec->catfile( $config{run}, $Work::Common::jobbase );
open( DB, ">$config{jsd}" ) || die "ERROR: Writing $config{jsd}: $!\n";
close DB;
print STDERR "# created job state log $config{jsd}\n" if $main::DEBUG;

# all this nice info, save the effort!
my $braindb = File::Spec->catfile( $config{run}, $Work::Common::brainbase );
open( DB, ">$braindb" ) || die "ERROR: Writing $braindb: $!\n";
while ( my ($k,$v) = each %config ) {
    print DB "$k $v\n";
}
close DB;
print STDERR "# created brain dump in $braindb\n" if $main::DEBUG;

# enter workflow into work db
my $workdb = Work::Workflow->new($props); # fail late
my $rv = $workdb->new_work( $config{basedir}, $config{vogroup}, 
			    $config{label}, $config{rundir},
			    $system{'user.name'}, $stat[9], -2 );
if ( $rv == 1 ) {
    print STDERR "# registered workflow into workman\n" if $main::DEBUG;
} elsif ( defined $rv && $rv == 0 ) {
    print STDERR "Info: Unable to register workflow with workman\n";
} else {
    print STDERR "Info: While registering workflow: ", $workdb->error, "\n";
}

# compile argument line from %initial record
my $extra = '';
foreach my $k ( keys %initial ) {
    $extra .= " -D$k=$initial{$k}";
}
$extra .= " -Dwf.properties=$wfrc" if defined $wfrc;
$extra .= " -Dpegasus.user.properties=$pegasusrc" if defined $pegasusrc;
$extra .= " $config{run}";

my $vr = File::Spec->catfile( dirname($0), 'pegasus-run' );
$vr = 'pegasus-run' if ( find_exec('pegasus-run') eq $vr );

# next step
print << "EOF";

I have concretized your abstract workflow. The workflow has been entered
into the workflow database with a state of "planned". The next step is 
to start or execute your workflow. The invocation required is

$vr $extra

EOF
exit 0;
