<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="commands">
  <title>Command Reference</title>

  <para>This chapter contains reference material for all the command-line
  tools distributed with Pegasus.</para>

  <section>
    <title>pegasus-version</title>

    <para>pegasus-version is a simple command-line tool that reports the
    version number of the Pegasus distribution being used.</para>
  </section>

  <section>
    <title>pegasus-plan</title>

    <para>pegasus-plan generates a concrete, executable workflow from an
    abstract workflow description (DAX).</para>
  </section>

  <section>
    <title>pegasus-run</title>

    <para>pegasus-run executes a workflow that has been planned using
    pegasus-plan.</para>
  </section>

  <section>
    <title>pegasus-remove</title>

    <para>pegasus-remove is used to abort a running workflow.</para>
  </section>

  <section>
    <title>pegasus-status</title>

    <para>pegasus-status reports on the status of a workflow.</para>
  </section>

  <section>
    <title>pegasus-analyzer</title>

    <para>pegasus-analyzer is used to debug failed workflows.</para>
  </section>

  <section>
    <title>pegasus-statistics</title>

    <para>pegasus-statistics reports statistics about a workflow.</para>
  </section>

  <section>
    <title>pegasus-plots</title>

    <para>pegasus-plots generates charts and graphs that illustrate the
    statistics and execution of a workflow.</para>
  </section>

  <section>
    <title>pegasus-transfer</title>

    <para>pegasus-transfer is a wrapper for several file transfer
    clients.</para>
  </section>

  <section>
    <title>pegasus-sc-client</title>

    <para>pegasus-sc-client is used to generate and modify site
    catalogs.</para>
  </section>

  <section>
    <title>pegasus-tc-client</title>

    <para>pegasus-tc-client is used to generate and modify transformation
    catalogs.</para>
  </section>

  <section>
    <title>pegasus-s3</title>

    <para>pegasus-s3 is a client for the Amazon S3 object storage service and
    any other storage services that conform to the Amazon S3 API, such as
    Eucalyptus Walrus.</para>

    <section>
      <title>URL Format</title>

      <para>All URLs for objects stored in S3 should be specified in the
      following format:</para>

      <programlisting>s3[s]://USER@SITE[/BUCKET[/KEY]]</programlisting>

      <para>The protocol part can be s3:// or s3s://. If s3s:// is used, then
      pegasus-s3 will force the connection to use SSL and override the setting
      in the configuration file. If s3:// is used, then whether the connection
      uses SSL or not is determined by the value of the 'endpoint' variable in
      the configuration for the site.</para>

      <para>The <emphasis>USER@SITE</emphasis> part is required, but the
      <emphasis>BUCKET</emphasis> and <emphasis>KEY</emphasis> parts may be
      optional depending on the context.</para>

      <para>The <emphasis>USER@SITE</emphasis> portion is referred to as the
      'identity', and the <emphasis>SITE</emphasis> portion is referred to as
      the site. Both the identity and the site are looked up in the
      configuration file (see pegasus-s3 Configuration) to determine the
      parameters to use when establishing a connection to the service. The
      site portion is used to find the host and port, whether to use SSL, and
      other things. The identity portion is used to determine which
      authentication tokens to use. This format is designed to enable users to
      easily use multiple services with multiple authentication tokens. Note
      that neither the <emphasis>USER</emphasis> nor the
      <emphasis>SITE</emphasis> portion of the URL have any meaning outside of
      pegasus-s3. They do not refer to real usernames or hostnames, but are
      rather handles used to look up configuration values in the configuration
      file.</para>

      <para>The <emphasis>BUCKET</emphasis> portion of the URL is the part
      between the 3rd and 4th slashes. Buckets are part of a global namespace
      that is shared with other users of the storage service. As such, they
      should be unique.</para>

      <para>The <emphasis>KEY</emphasis> portion of the URL is anything after
      the 4th slash. Keys can include slashes, but S3-like storage services do
      not have the concept of a directory like regular file systems. Instead,
      keys are treated like opaque identifiers for individual objects. So, for
      example, the keys 'a/b' and 'a/c' have a common prefix, but cannot be
      said to be in the same 'directory'.</para>

      <para>Some example URLs are:</para>

      <programlisting>s3://ewa@amazon
s3://juve@skynet/gideon.isi.edu
s3://juve@magellan/pegasus-images/centos-5.5-x86_64-20101101.part.1
s3s://ewa@amazon/pegasus-images/data.tar.gz</programlisting>
    </section>

    <section>
      <title>Subcommands</title>

      <para>pegasus-s3 has several subcommands for different storage service
      operations.</para>

      <section>
        <title>help</title>

        <para><emphasis role="bold">pegasus-s3 help</emphasis></para>

        <para>The <emphasis role="bold">help</emphasis> subcommand lists all
        available subcommands.</para>
      </section>

      <section>
        <title>ls</title>

        <para><emphasis role="bold">pegasus-s3 ls [options]
        URL...</emphasis></para>

        <para>The <emphasis role="bold">ls</emphasis> subcommand lists the
        contents of a URL. If the URL does not contain a bucket, then all the
        buckets owned by the user are listed. If the URL contains a bucket,
        but no key, then all the keys in the bucket are listed. If the URL
        contains a bucket and a key, then all keys in the bucket that begin
        with the specified key are listed.</para>
      </section>

      <section>
        <title>mkdir</title>

        <para><emphasis role="bold">pegasus-s3 mkdir [options]
        URL...</emphasis></para>

        <para>The <emphasis role="bold">mkdir</emphasis> subcommand creates
        one or more buckets.</para>
      </section>

      <section>
        <title>rmdir</title>

        <para><emphasis role="bold">pegasus-s3 rmdir [options]
        URL...</emphasis></para>

        <para>The <emphasis role="bold">rmdir</emphasis> subcommand deletes
        one or more buckets from the storage service. In order to delete a
        bucket, the bucket must be empty.</para>
      </section>

      <section>
        <title>rm</title>

        <para><emphasis role="bold">pegasus-s3 rm [options]
        URL...</emphasis></para>

        <para>The <emphasis role="bold">rm</emphasis> subcommand deletes one
        or more keys from the storage service.</para>
      </section>

      <section>
        <title>put</title>

        <para><emphasis role="bold">pegasus-s3 put [options] FILE
        URL</emphasis></para>

        <para>The <emphasis role="bold">put</emphasis> subcommand stores the
        file specified by <emphasis>FILE</emphasis> in the storage service
        under the bucket and key specified by <emphasis>URL</emphasis>. If the
        URL contains a bucket, but not a key, then the file name is used as
        the key.</para>

        <para>If a transient failure occurs, then the upload will be retried
        several times before pegasus-s3 gives up and fails.</para>

        <para>The put subcommand can do both chunked and parallel uploads if
        the service supports multipart uploads (see multipart_uploads in the
        configuration). Currently only Amazon S3 supports multipart
        uploads.</para>

        <para>This subcommand will check the size of the file to make sure it
        can be stored before attempting to store it.</para>

        <para>Chunked uploads are useful to reduce the probability of an
        upload failing. If an upload is chunked, then pegasus-s3 issues
        separate PUT requests for each chunk of the file. Specifying smaller
        chunks (using --chunksize) will reduce the chances of an upload
        failing due to a transient error. Chunksizes can range from 5 MB to
        1GB (chunk sizes smaller than 5 MB produced incomplete uploads on
        Amazon S3). The maximum number of chunks for any single file is
        10,000, so if a large file is being uploaded with a small chunksize,
        then the chunksize will be increased to fit within the 10,000 chunk
        limit. By default, the file will be split into 10 MB chunks if the
        storage service supports multipart uploads. Chunked uploads can be
        disabled by specifying a chunksize of 0. If the upload is chunked,
        then each chunk is retried independently under transient failures. If
        any chunk fails permanently, then the upload is aborted.</para>

        <para>Parallel uploads can increase performance for services that
        support multipart uploads. In a parallel upload the file is split into
        N chunks and each chunk is uploaded concurrently by one of M threads
        in first-come, first-served fashion. If the chunksize is set to 0,
        then parallel uploads are disabled. If M &gt; N, then the actual
        number of threads used will be reduced to N. The number of threads can
        be specified using the --parallel argument. If --parallel is 0 or 1,
        then only a single thread is used. The default value is 0. There is no
        maximum number of threads, but it is likely that the link will be
        saturated by ~4 threads. Very high-bandwidth, long-delay links may get
        better results with up to ~8 threads.</para>

        <note>
          <para>Under certain circumstances, when a multipart upload fails it
          could leave behind data on the server. When a failure occurs the put
          subcommand will attempt to abort the upload. If the upload cannot be
          aborted, then a partial upload may remain on the server. To check
          for partial uploads run the <emphasis role="bold">lsup</emphasis>
          subcommand. If you see an upload that failed in the output of lsup,
          then run the <emphasis role="bold">rmup</emphasis> subcommand to
          remove it.</para>
        </note>
      </section>

      <section>
        <title>get</title>

        <para><emphasis role="bold">pegasus-s3 get [options] URL
        [FILE]</emphasis></para>

        <para>The <emphasis role="bold">get</emphasis> subcommand retrives an
        object from the storage service identified by <emphasis>URL</emphasis>
        and stores it in the file specified by <emphasis>FILE</emphasis>. If
        FILE is not specified, then the key is used as the file name (Note: if
        the key has slashes, then the file name will be a relative
        subdirectory, but pegasus-s3 will not create the subdirectory if it
        does not exist).</para>

        <para>If a transient failure occurs, then the download will be retried
        several times before pegasus-s3 gives up and fails.</para>

        <para>The get subcommand can do both chunked and parallel downloads if
        the service supports ranged downloads (see ranged_downloads in the
        configuration). Currently only Amazon S3 has good support for ranged
        downloads. Eucalyptus Walrus supports ranged downloads, but the
        current release, 1.6, is inconsistent with the Amazon interface and
        has a bug that causes ranged downloads to hang in some cases. It is
        recommended that ranged downloads not be used with Eucalyptus until
        these issues are resolved.</para>

        <para>Chunked downloads can be used to reduce the probability of a
        download failing. When a download is chunked, pegasus-s3 issues
        separate GET requests for each chunk of the file. Specifying smaller
        chunks (uisng --chunksize) will reduce the chances that a download
        will fail to do a transient error. Chunk sizes can range from 1 MB to
        1 GB. By default, a download will be split into 10 MB chunks if the
        site supports ranged downloads. Chunked downloads can be disabled by
        specifying a chunksize of 0. If a download is chunked, then each chunk
        is retried independently under transient failures. If any chunk fails
        permanently, then the download is aborted.</para>

        <para>Parallel downloads can increase performance for services that
        support ranged downloads. In a parallel download, the file to be
        retrieved is split into N chunks and each chunk is downloaded
        concurrently by one of M threads in a first-come, first-served
        fashion. If the chunksize is 0, then parallel downloads are disabled.
        If M &gt; N, then the actual number of threads used will be reduced to
        N. The number of threads can be specified using the --parallel
        argument. If --parallel is 0 or 1, then only a single thread is used.
        The default value is 0. There is no maximum number of threads, but it
        is likely that the link will be saturated by ~4 threads. Very
        high-bandwidth, long-delay links may get better results with up to ~8
        threads.</para>
      </section>

      <section>
        <title>lsup</title>

        <para><emphasis role="bold">pegasus-s3 lsup [options]
        URL</emphasis></para>

        <para>The <emphasis role="bold">lsup</emphasis> subcommand lists
        active uploads. The URL specified should point to a bucket. This
        command is only valid if the site supports multipart uploads. The
        output of this command is a list of keys and upload IDs.</para>

        <para>This subcommand is used with <emphasis
        role="bold">rmup</emphasis> to help recover from failures of multipart
        uploads.</para>
      </section>

      <section>
        <title>rmup</title>

        <para><emphasis role="bold">pegasus-s3 rmup [options] URL
        UPLOAD</emphasis></para>

        <para>The <emphasis role="bold">rmup</emphasis> subcommand cancels and
        active upload. The <emphasis>URL</emphasis> specified should point to
        a bucket, and <emphasis>UPLOAD</emphasis> is the long, complicated
        upload ID shown by the <emphasis role="bold">lsup</emphasis>
        subcommand.</para>

        <para>This subcommand is used with <emphasis
        role="bold">lsup</emphasis> to recover from failures of multipart
        uploads.</para>
      </section>
    </section>

    <section>
      <title>pegasus-s3 Configuration</title>

      <para>Each user should specify a configuration file that pegasus-s3 will
      use to look up connection parameters and authentication tokens.</para>

      <section>
        <title>Configuration file search path</title>

        <para>This client will look in the following locations, in order, to
        locate the user's configuration file:</para>

        <orderedlist>
          <listitem>
             The -C/--conf argument 
          </listitem>

          <listitem>
             The S3CFG environment variable 
          </listitem>

          <listitem>
             ~/.s3cfg 
          </listitem>
        </orderedlist>

        <para>If it does not find the configuration file in one of these
        locations it will fail with an error.</para>
      </section>

      <section>
        <title>Configuration file format</title>

        <para>The configuration file is in INI format and contains two types
        of entries.</para>

        <para>The first type of entry is a <emphasis role="bold">site
        entry</emphasis>, which specifies the configuration for a storage
        service. This entry specifies the service endpoint that pegasus-s3
        should connect to for the site, and some optional features that the
        site may support. Here is an example of a site entry for Amazon
        S3:</para>

        <programlisting>[amazon]
endpoint = http://s3.amazonaws.com/</programlisting>

        <para>The other type of entry is an <emphasis role="bold">identity
        entry</emphasis>, which specifies the authentication information for a
        user at a particular site. Here is an example of an identity
        entry:</para>

        <programlisting>[pegasus@amazon]
access_key = 90c4143642cb097c88fe2ec66ce4ad4e
secret_key = a0e3840e5baee6abb08be68e81674dca</programlisting>

        <para>It is important to note that user names and site names used are
        only logical--they do not correspond to actual hostnames or usernames,
        but are simply used as a convenient way to refer to the services and
        identities used by the client.</para>

        <para>The configuration file should be saved with limited permissions.
        Only the owner of the file should be able to read from it and write to
        it (i.e. it should have permissions of 0600 or 0400). If the file has
        more liberal permissions, then pegasus-s3 will fail with an error
        message. The purpose of this is to prevent the authentication tokens
        stored in the configuration file from being accessed by other
        users.</para>
      </section>

      <section>
        <title>Configuration variables</title>

        <table>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>Variable</entry>

                <entry>Scope</entry>

                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>endpoint</entry>

                <entry>site</entry>

                <entry>The URL of the web service endpoint. If the URL begins
                with 'https', then SSL will be used.</entry>
              </row>

              <row>
                <entry>max_object_size</entry>

                <entry>site</entry>

                <entry>The maximum size of an object in GB (default:
                5GB)</entry>
              </row>

              <row>
                <entry>multipart_uploads</entry>

                <entry>site</entry>

                <entry>Does the service support multipart uploads (True/False,
                default: False)</entry>
              </row>

              <row>
                <entry>ranged_downloads</entry>

                <entry>site</entry>

                <entry>Does the service support ranged downloads? (True/False,
                default: False)</entry>
              </row>

              <row>
                <entry>access_key</entry>

                <entry>identity</entry>

                <entry>The access key for the identity</entry>
              </row>

              <row>
                <entry>secret_key</entry>

                <entry>identity</entry>

                <entry>The secret key for the identity</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title>Example configuration</title>

        <para>This is an example configuration that specifies a single site
        (amazon) and a single identity (pegasus@amazon). For this site the
        maximum object size is 5TB, and the site supports both multipart
        uploads and ranged downloads, so both uploads and downloads can be
        done in parallel.</para>

        <programlisting>[amazon]
endpoint = https://s3.amazonaws.com/
max_object_size = 5120
multipart_uploads = True
ranged_downloads = True

[pegasus@amazon]
access_key = 90c4143642cb097c88fe2ec66ce4ad4e
secret_key = a0e3840e5baee6abb08be68e81674dca

[magellan]
# NERSC Magellan is a Eucalyptus site. It doesn't support multipart uploads,
# or ranged downloads (the defaults), and the maximum object size is 5GB
# (also the default)
endpoint = https://128.55.69.235:8773/services/Walrus

[juve@magellan]
access_key = quwefahsdpfwlkewqjsdoijldsdf
secret_key = asdfa9wejalsdjfljasldjfasdfa

[voekler@magellan]
# Each site can have multiple associated identities
access_key = asdkfaweasdfbaeiwhkjfbaqwhei
secret_key = asdhfuinakwjelfuhalsdflahsdl</programlisting>
      </section>
    </section>
  </section>

  <section>
    <title>pegasus-exitcode</title>

    <para>pegasus-exitcode is a utility that examines the STDOUT of a job to
    determine if the job failed, and renames the STDOUT and STDERR files of a
    job to preserve them in case the job is retried.</para>

    <para>Pegasus uses pegasus-exitcode as the DAGMan postscript for all jobs
    submitted via Globus GRAM. This tool exists as a workaround to a known
    problem with Globus where the exitcodes of GRAM jobs are not returned.
    This is a problem because Pegasus uses the exitcode of a job to determine
    if the job failed or not.</para>

    <para>In order to get around the exitcode problem, Pegasus wraps all GRAM
    jobs with Kickstart, which records the exitcode of the job in an XML
    invocation record, which it writes to the job's STDOUT. The STDOUT is
    transferred from the execution host back to the submit host when the job
    terminates. After the job terminates, DAGMan runs the job's postscript,
    which Pegasus sets to be pegasus-exitcode. pegasus-exitcode looks at the
    invocation record generated by kickstart to see if the job succeeded or
    failed. If the invocation record indicates a failure, then
    pegasus-exitcode returns a non-zero result, which indicates to DAGMan that
    the job has failed. If the invocation record indicates that the job
    succeeded, then pegasus-exitcode returns 0, which tells DAGMan that the
    job succeeeded.</para>

    <para>pegasus-exitcode performs several checks to determine whether a job
    failed or not. These checks include:</para>

    <orderedlist>
      <listitem>
        <para>Is STDOUT empty? If it is empty, then the job failed.</para>
      </listitem>

      <listitem>
        <para>Are there any &lt;status&gt; tags with a non-zero value? If
        there are, then the job failed. Note that, if this is a clustered job,
        there could be multiple &lt;status&gt; tags, one for each task. If any
        of them are non-zero, then the job failed.</para>
      </listitem>

      <listitem>
        <para>Is there at least one &lt;status&gt; tag with a zero value?
        There must be at least one successful invocation or the job has
        failed.</para>
      </listitem>
    </orderedlist>

    <para>In addition, pegasus-exitcode allows the caller to specify the
    exitcode returned by Condor using the --return argument. This can be
    passed to pegasus-exitcode in a DAGMan post script by using the $RETURN
    variable. If this value is non-zero, then pegasus-exitcode returns a
    non-zero result before performing any other checks. For GRAM jobs, the
    value of $RETURN will always be 0 regardless of whether the job failed or
    not.</para>

    <para>Also, pegasus-exitcode allows the caller to specify the number of
    successful tasks it should see using the --tasks argument. If
    pegasus-exitcode does not see N successful tasks, where N is set by
    --tasks, then it will return a non-zero result. The default value is 1.
    This can be used to detect failures in clustered jobs where, for any
    number of reasons, invocation records do not get generated for all the
    tasks in the clustered job.</para>

    <para>In addition to checking the success/failure of a job,
    pegasus-exitcode also renames the STDOUT and STDERR files of the job so
    that if the job is retried, the STDOUT and STDERR of the previous run are
    not lost. It does this by appending a sequence number to the end of the
    files. For example, if the STDOUT file is called "job.out", then the first
    time the job is run pegasus-exitcode will rename the file "job.out.000".
    If the job is run again, then pegasus-exitcode sees that "job.out.000"
    already exists and renames the file "job.out.001". It will continue to
    rename the file by incrementing the sequence number every time the job is
    executed.</para>
  </section>

  <section>
    <title>kickstart</title>

    <para>kickstart is a job wrapper that collects data about a job's
    execution environment, performance, and output.</para>
  </section>
</chapter>
