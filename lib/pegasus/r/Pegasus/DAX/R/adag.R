#' Representation of a directed acyclic graph in XML (DAX)
#'
#' @param name The name of the workflow
#' @param count Total number of DAXes that will be created
#' @param index Zero-based index of this DAX
#' @return An object with a DAX
#' @export
#'
#' @examples
#' # Example of a black diamond workflow
#' # Create a DAX
#' diamond <- ADAG("diamond")
#'
#' # Add some metadata
#' diamond <- Metadata(diamond, "name", "diamond")
#' diamond <- Metadata(diamond, "createdby", "Rafael Ferreira da Silva")
#'
#' # Add input file to the DAX-level replica catalog
#' a <- File("f.a")
#' a <- AddPFN(a, PFN("gsiftp://site.com/inputs/f.a", "site"))
#' a <- Metadata(a, "size", "1024")
#' diamond <- AddFile(diamond, a)
#'
#' # Add executables to the DAX-level replica catalog
#' e.preprocess <- Executable(namespace="bd",name="process",version="4.0",os="linux",arch="x86_64")
#' e.preprocess <- Metadata(e.preprocess,"size","2048")
#' e.preprocess <- AddPFN(e.preprocess, PFN("gsiftp://site.com/bin/preprocess", "site"))
#' diamond <- AddExecutable(diamond, e.preprocess)
#'
#' e.findrange <- Executable(namespace="bd",name="frange",version="4.0",os="linux",arch="x86_64")
#' e.findrange <- AddPFN(e.findrange, PFN("gsiftp://site.com/bin/findrange", "site"))
#' diamond <- AddExecutable(diamond, e.findrange)
#'
#' e.analyze <- Executable(namespace="bd",name="analyze",version="4.0",os="linux",arch="x86_64")
#' e.analyze <- AddPFN(e.analyze, PFN("gsiftp://site.com/bin/analyze", "site"))
#' diamond <- AddExecutable(diamond, e.analyze)
#'
#' # Add a preprocess job
#' preprocess <- Job(e.preprocess)
#' preprocess <- Metadata(preprocess, "time", "60")
#' b1 <- File("f.b1")
#' b2 <- File("f.b2")
#' preprocess <- AddArguments(preprocess, list("-a preprocess","-T60","-i",a,"-o",b1,b2))
#' preprocess <- Uses(preprocess, a, link=DAX3.Link$INPUT)
#' preprocess <- Uses(preprocess, b1, link=DAX3.Link$OUTPUT, transfer=TRUE)
#' preprocess <- Uses(preprocess, b2, link=DAX3.Link$OUTPUT, transfer=TRUE)
#' diamond <- AddJob(diamond, preprocess)
#'
#' # Add left Findrange job
#' frl <- Job(e.findrange)
#' frl <- Metadata(frl, "time", "60")
#' c1 <- File("f.c1")
#' frl <- AddArguments(frl, list("-a findrange","-T60","-i",b1,"-o",c1))
#' frl <- Uses(frl, b1, link=DAX3.Link$INPUT)
#' frl <- Uses(frl, c1, link=DAX3.Link$OUTPUT, transfer=TRUE)
#' diamond <- AddJob(diamond, frl)
#'
#' # Add right Findrange job
#' frr <- Job(e.findrange)
#' frr <- Metadata(frr, "time", "60")
#' c2 <- File("f.c2")
#' frr <- AddArguments(frr, list("-a findrange","-T60","-i",b2,"-o",c2))
#' frr <- Uses(frr, b2, link=DAX3.Link$INPUT)
#' frr <- Uses(frr, c2, link=DAX3.Link$OUTPUT, transfer=TRUE)
#' diamond <- AddJob(diamond, frr)
#'
#' # Add Analyze job
#' analyze <- Job(e.analyze)
#' analyze <- Metadata(analyze, "time", "60")
#' d <- File("f.d")
#' analyze <- AddArguments(analyze, list("-a analyze","-T60","-i",c1,c2,"-o",d))
#' analyze <- Uses(analyze, c1, link=DAX3.Link$INPUT)
#' analyze <- Uses(analyze, c2, link=DAX3.Link$INPUT)
#' analyze <- Uses(analyze, d, link=DAX3.Link$OUTPUT, transfer=TRUE)
#' diamond <- AddJob(diamond, analyze)
#'
#' # Add dependencies
#' diamond <- Depends(diamond, parent=preprocess, child=frl)
#' diamond <- Depends(diamond, parent=preprocess, child=frr)
#' diamond <- Depends(diamond, parent=frl, child=analyze)
#' diamond <- Depends(diamond, parent=frr, child=analyze)
#'
#' # Get generated diamond dax
#' WriteXML(diamond, stdout())
#'
#' @export
ADAG <- function(name, count=NULL, index=NULL) {

  if (!IsDefined(name)) {
    stop(paste("Invalid ADAG name:", name))
  }
  if (IsDefined(count)) {
    count <- as.integer(count)
  }
  if (IsDefined(index)) {
    index <- as.integer(index)
  }

  object <- list(name=name, count=count, index=index, sequence=1, jobs=list(), files=c(),
                 executables=c(), dependencies=c(), transformations=c(),
                 invoke.mixin=InvokeMixin(), metadata.mixin=MetadataMixin())
  class(object) <- "ADAG"
  return (object)
}

#' Get an autogenerated ID for the next job
#'
#' @param adag ADAG object
#' @return DAX object with updated sequence number and the next.id in list format: \code{list(ADAG, next.id)}
#' @seealso \code{\link{ADAG}}
NextJobID <- function(adag) {
  next.id <- NULL
  while (is.null(next.id) || next.id %in% names(adag$jobs)) {
    next.id <- paste("ID", sprintf("%07d", adag$sequence), sep="")
    adag$sequence <- adag$sequence + 1
  }
  return(list(adag=adag, next.id=next.id))
}

#' Get a Job/DAG/DAX
#'
#' @param adag ADAG object
#' @param jobid Job identification
#' @return Job/DAG/DAX object
#' @seealso \code{\link{ADAG}}, \code{\link{HasJob}}
#' @export
GetJob <- function(adag, jobid) {
  if (!(jobid %in% names(adag$jobs))) {
    stop(paste("Job not found:", jobid))
  }
  return(adag$jobs[jobid])
}

#' Add a job to the ADAG
#'
#' @param adag ADAG object
#' @param job Job object
#' @return ADAG object with the job appended
#' @seealso \code{\link{ADAG}}, \code{\link{RemoveJob}}
#' @export
AddJob <- function(adag, job) {
  # Add an auto-generated ID if the job doesn't have one
  if (HasJob(adag, job)) {
    stop(paste("Duplicate job:", job))
  }
  if (!IsDefined(job$abstract.job$id)) {
    l <- NextJobID(adag)
    job$abstract.job$id <- l$next.id
    adag <- l$adag
  }
  adag$jobs[[job$abstract.job$id]] <- job
  return(adag)
}

#' Test to see if job is in this ADAG
#'
#' @description
#' The job parameter can be an object or a job ID.
#'
#' @param adag ADAG object
#' @param job Job/DAG/DAX object
#' @return If the Job/DAG/DAX is in the ADAG
#' @seealso \code{\link{ADAG}}, \code{\link{GetJob}}
HasJob <- function(adag, job) {
  if (class(job) == "Job" || class(job) == "DAG" || class(job) == "DAX") {
    for (j in adag$jobs) {
      if (Equals(j, job)) {
        return(TRUE)
      }
    }
    return(FALSE)
  } else {
    return(job %in% names(adag$jobs))
  }
}

#' Remove job from the ADAG
#'
#' @param adag ADAG object
#' @param job Job/DAG/DAX object
#' @return The ADAG object without the Job/DAG/DAX
#' @seealso \code{\link{ADAG}}, \code{\link{AddJob}}, \code{\link{ClearJobs}}
#' @export
RemoveJob <- function(adag, job) {
  if (!HasJob(adag, job)) {
    stop("Job not found", job)
  }
  if (class(job) == "Job" || class(job) == "DAG" || class(job) == "DAX") {
    adag$jobs[job$abstract.job$id] <- NULL
  } else {
    adag$jobs[job] <- NULL
  }
  return(adag)
}

#' Remove all jobs
#'
#' @param adag ADAG object
#' @return The ADAG object with no jobs
#' @seealso \code{\link{ADAG}}, \code{\link{RemoveJob}}, \code{\link{AddJob}}
#' @export
ClearJobs <- function(adag) {
  adag$jobs <- list()
  return(adag)
}

#' Add a sub-DAX (synonym for addJob)
#'
#' @param adag ADAG object
#' @param dax Sub-DAX to be appended
#' @return The ADAG object with the sub-DAX appended
#' @seealso \code{\link{ADAG}}, \code{\link{AddJob}}, \code{\link{DAX}}
#' @export
AddDAX <- function(adag, dax) {
  if (class(dax) != "DAX") {
    stop(paste("Not a DAX", dax))
  }
  adag <- AddJob(adag, dax)
  return(adag)
}

#' Add a sub-DAG (synonym for addJob)
#'
#' @param adag ADAG object
#' @param dag Sub-DAG to be appended
#' @return The ADAG object with the sub-DAG appended
#' @seealso \code{\link{ADAG}}, \code{\link{AddJob}}, \code{\link{DAG}}
#' @export
AddDAG <- function(adag, dag) {
  if (class(dag) != "DAG") {
    stop(paste("Not a DAG", dag))
  }
  adag <- AddJob(adag, dag)
  return(adag)
}

#' Add a file to the DAX
#'
#' @param adag ADAG object
#' @param file File object
#' @return The ADAG object with the file appended
#' @seealso \code{\link{ADAG}}, \code{\link{File}}, \code{\link{RemoveFile}}, \code{\link{ClearFiles}}
#' @export
AddFile <- function(adag, file) {
  if (class(file) != "File") {
    stop(paste("Invalid file:", file$catalog.type$name))
  }
  if (HasFile(adag, file)) {
    stop(paste("Duplicate file:", file$catalog.type$name))
  }
  adag$files <- AppendToList(adag$files, file)
  return(adag)
}

#' Check to see if file is in the ADAG
#'
#' @param adag ADAG object
#' @param file File object
#' @return If the ADAG object contains the file
#' @seealso \code{\link{ADAG}}, \code{\link{File}}
HasFile <- function(adag, file) {
  for (f in adag$files) {
    if (Equals(f, file)) {
      return(TRUE)
    }
  }
  return(FALSE)
}

#' Remove file from this ADAG
#'
#' @param adag ADAG object
#' @param file File object
#' @return The ADAG object without the file
#' @seealso \code{\link{ADAG}}, \code{\link{File}}, \code{\link{AddFile}}, \code{\link{ClearFiles}}
#' @export
RemoveFile <- function(adag, file) {
  if (length(adag$files) > 0) {
    for (i in 1:length(adag$files)) {
      o <- adag$files[[i]]
      if (Equals(o, file)) {
        adag$files[i] <- NULL
        return(adag)
      }
    }
  }
  stop(paste("File not found:", file))
}

#' Remove all files
#'
#' @param adag ADAG object
#' @return The ADAG object with no files
#' @seealso \code{\link{ADAG}}, \code{\link{File}}, \code{\link{AddFile}}, \code{\link{RemoveFile}}
#' @export
ClearFiles <- function(adag) {
  adag$files <- c()
  return(adag)
}

#' Add an executable to the ADAG
#'
#' @param adag ADAG object
#' @param executable Executable object
#' @return The ADAG object with the executable appended
#' @seealso \code{\link{ADAG}}, \code{\link{Executable}},
#'  \code{\link{RemoveExecutable}}, \code{\link{ClearExecutables}}
#' @export
AddExecutable <- function(adag, executable) {
  if (HasExecutable(adag, executable)) {
    stop(paste("Duplicate executable:", executable$catalog.type$name))
  }
  adag$executables <- AppendToList(adag$executables, executable)
  return(adag)
}

#' Check if executable is in this ADAG
#'
#' @param adag ADAG object
#' @param executable Executable object
#' @return If the executable is in the ADAG
#' @seealso \code{\link{ADAG}}, \code{\link{Executable}}
HasExecutable <- function(adag, executable) {
  for (e in adag$executables) {
    if (Equals(e, executable)) {
      return(TRUE)
    }
  }
  return(FALSE)
}

#' Remove executable from the ADAG
#'
#' @param adag ADAG object
#' @param executable Executable object
#' @return The ADAG object without the executable
#' @seealso \code{\link{ADAG}}, \code{\link{Executable}},
#'  \code{\link{AddExecutable}}, \code{\link{ClearExecutables}}
#' @export
RemoveExecutable <- function(adag, executable) {
  if (length(adag$executables) > 0) {
    for (i in 1:length(adag$executables)) {
      o <- adag$executables[[i]]
      if (Equals(o, executable)) {
        adag$executables[i] <- NULL
        return(adag)
      }
    }
  }
  stop(paste("Executable not found:", file))
}

#' Remove all executables
#'
#' @param adag ADAG object
#' @return The ADAG object with no executables
#' @seealso \code{\link{ADAG}}, \code{\link{Executable}},
#'  \code{\link{AddExecutable}}, \code{\link{RemoveExecutable}}
#' @export
ClearExecutables <- function(adag) {
  adag$executables <- c()
  return(adag)
}

#' Add a transformation to the ADAG
#'
#' @param adag ADAG object
#' @param transformation Transformation object
#' @return The ADAG object with the transformation appended
#' @seealso \code{\link{ADAG}}, \code{\link{Transformation}},
#'  \code{\link{RemoveTransformation}}, \code{\link{ClearTransformations}}
#' @export
AddTransformation <- function(adag, transformation) {
  if (HasTransformation(adag, transformation)) {
    stop(paste("Duplicate transformation:", transformation))
  }
  adag$transformations <- AppendToList(adag$transformations, transformation)
  return(adag)
}

#' Check to see if transformation is in the ADAG
#'
#' @param adag ADAG object
#' @param transformation Transformation object
#' @return If the ADAG has the transformation
#' @seealso \code{\link{ADAG}}, \code{\link{Transformation}}
HasTransformation <- function(adag, transformation) {
  for (t in adag$transformations) {
    if (Equals(t, transformation)) {
      return(TRUE)
    }
  }
  return(FALSE)
}

#' Remove transformation from the ADAG
#'
#' @param adag ADAG object
#' @param transformation Transformation object
#' @return The ADAG object without the transformation
#' @seealso \code{\link{ADAG}}, \code{\link{Transformation}},
#'  \code{\link{AddTransformation}}, \code{\link{ClearTransformations}}
#' @export
RemoveTransformation <- function(adag, transformation) {
  if (length(adag$transformations) > 0) {
    for (i in 1:length(adag$transformations)) {
      o <- adag$transformations[[i]]
      if (Equals(o, transformation)) {
        adag$transformations[i] <- NULL
        return(adag)
      }
    }
  }
  stop(paste("Transformation not found:", file))
}

#' Remove all transformations
#'
#' @param adag ADAG object
#' @return The ADAG object with no transformations
#' @seealso \code{\link{ADAG}}, \code{\link{Transformation}},
#'  \code{\link{AddTransformation}}, \code{\link{RemoveTransformation}}
#' @export
ClearTransformations <- function(adag) {
  adag$transformations <- c()
  return(adag)
}

#' Add a dependency to the workflow
#'
#' @param adag The ADAG object
#' @param child The child job/dax/dag or id
#' @param parent The parent job/dax/dag or id
#' @param edge.label A label for the edge (optional)
#' @return The ADAG object with the dependency appended
#' @seealso \code{\link{ADAG}}, \code{\link{Dependency}}, \code{\link{AddDependency}}
#' @export
Depends <- function(adag, child, parent, edge.label=NULL) {
  # find jobs to fix ID
  p.parent <- NULL
  p.child <- NULL
  for (j in adag$jobs) {
    if (Equals(parent, j)) {
      p.parent <- j
    } else if (Equals(child, j)) {
      p.child <- j
    }
    if (!is.null(p.parent) && !is.null(p.child)) {
      break
    }
  }
  d <- Dependency(p.parent, p.child, edge.label)
  adag <- AddDependency(adag, d)
  return(adag)
}

#' Add a dependency to the workflow
#'
#' @param adag The ADAG object
#' @param dep The dependency object
#' @return The ADAG object containing the dependency
#' @seealso \code{\link{ADAG}}, \code{\link{Dependency}},
#'  \code{\link{Depends}}, \code{\link{RemoveDependency}}
#' @export
AddDependency <- function(adag, dep) {
  if (HasDependency(adag, dep)) {
    stop(paste("Duplicate dependency:", dep))
  }
  # Check the jobs
  if (!(dep$parent %in% names(adag$jobs))) {
    stop(paste("Parent not found:", dep$parent))
  }
  if (!(dep$child %in% names(adag$jobs))) {
    stop(paste("Child not found:", dep$child))
  }
  adag$dependencies <- AppendToList(adag$dependencies, dep)
  return(adag)
}

#' Check to see if dependency exists
#'
#' @param adag The ADAG object
#' @param dep The dependency object
#' @return If the ADAG contains the dependency
#' @seealso \code{\link{ADAG}}, \code{\link{Dependency}}
HasDependency <- function(adag, dep) {
  for (d in adag$dependencies) {
    if (Equals(d, dep)) {
      return(TRUE)
    }
  }
  return(FALSE)
}

#' Remove dependency from workflow
#'
#' @param adag The ADAG object
#' @param dep The dependency object
#' @return The ADAG object without the dependency
#' @seealso \code{\link{ADAG}}, \code{\link{Dependency}},
#'  \code{\link{Depends}}, \code{\link{AddDependency}}
#' @export
RemoveDependency <- function(adag, dep) {
  if (length(adag$dependencies) > 0) {
    for (i in 1:length(adag$dependencies)) {
      o <- adag$dependencies[[i]]
      if (Equals(o, dep)) {
        adag$dependencies[i] <- NULL
        return(adag)
      }
    }
  }
  stop(paste("Dependency not found:", file))
}

#' Remove all dependencies
#'
#' @param adag The ADAG object
#' @return The ADAG object with no dependencies
#' @seealso \code{\link{ADAG}}, \code{\link{Dependency}},
#'  \code{\link{Depends}}, \code{\link{AddDependency}},
#'  \code{\link{RemoveDependency}}
#' @export
ClearDependencies <- function(adag) {
  adag$dependencies <- c()
  return(adag)
}

#' @details
#' For \code{ADAG}: This is primarily intended for testing. If you have a large
#' ADAG you should use writeXML instead.
#'
#' @seealso \code{\link{ADAG}}, \code{\link{WriteXML}}
#'
#' @rdname ToXML
#' @method ToXML ADAG
ToXML.ADAG <- function(obj) {
  return(capture.output(WriteXML(obj)))
}

#' Write the ADAG to an XML file
#'
#' @param adag The ADAG object
#' @param filename Name of the file
#' @seealso \code{\link{ADAG}}, \code{\link{WriteXML}}
#' @export
WriteXMLFile <- function(adag, filename) {
  WriteXML(adag, filename)
}

#' Write the ADAG as XML to a stream
#'
#' @examples
#' dax <- ADAG('diamond')
#' WriteXML(dax, stdout())
#' WriteXML(dax, 'diamond.dax')
#'
#' @param adag The ADAG object
#' @param out The stream object (e.g., \code{stdout()}, or a filename)
#' @seealso \code{\link{ADAG}}
#' @export
WriteXML <- function(adag, out) {
  sink(out)

  # Preamble
  cat('<?xml version="1.0" encoding="UTF-8"?>\n')

  cat(paste('<!-- generated: ', Sys.time(), ' -->\n', sep=""))
  cat(paste('<!-- generated by: ', Sys.info()[['user']], ' -->\n', sep=""))
  cat('<!-- generator: R -->\n')

  # Open tag
  cat(paste('<adag xmlns="', kSchema.Namespace, '" ', sep=""))
  cat('xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ')
  cat(paste('xsi:schemaLocation="', kSchema.Namespace, ' ', kSchema.Location, '" ', sep=""))
  cat(paste('version="', kSchema.Version, '" ', sep=""))
  cat(paste('name="', adag$name, '"', sep=""))
  if(IsDefined(adag$count)) {
    cat(' count="', adag$count, '"')
  }
  if(IsDefined(adag$index)) {
    cat(' index="', adag$index, '"')
  }
  cat('>\n')

  # Metadata
  cat('\t<metadata key="dax.api">R</metadata>\n')
  for(m in adag$metadata.mixin$metadata.l) {
    cat('\t')
    cat(capture.output(WriteElement(ToXML(m), level=1)))
    cat('\n')
  }

  # Invocations
  for (i in adag$invoke.mixin$invocations) {
    cat('\t')
    cat(paste(capture.output(WriteElement(ToXML(i), level=1))), sep="\n")
    cat('\n')
  }

  # Files
  for (f in adag$files) {
    cat('\t')
    cat(paste(capture.output(WriteElement(ToXML(f), level=1))), sep="\n")
    cat('\n')
  }

  # Executables
  for (e in adag$executables) {
    cat('\t')
    cat(paste(capture.output(WriteElement(ToXML(e), level=1))), sep="\n")
    cat('\n')
  }

  # Transformations
  for (t in adag$transformations) {
    cat('\t')
    cat(paste(capture.output(WriteElement(ToXML(t), level=1))), sep="\n")
    cat('\n')
  }

  # Jobs
  if (length(adag$jobs) > 0) {
    keys <- sort(names(adag$jobs))
    for (jobid in keys) {
      job <- adag$jobs[[jobid]]
      cat('\t')
      cat(paste(capture.output(WriteElement(ToXML(job), level=1))), sep="\n")
      cat('\n')
    }
  }

  # Dependencies
  # Since we store dependencies as tuples, but we need to print them as nested elements
  # we first build a map of all the children that maps child -> [(parent,label),...]
  children <- list()
  for(dep in adag$dependencies) {
    if(!(dep$child %in% names(children))) {
      children[[dep$child]] <- list()
    }
    children[[dep$child]] <- AppendToList(children[[dep$child]], list(dep$parent, dep$edge.label))
  }

  # Now output all the xml in sorted order by child, then parent
  if (length(children) > 0) {
    keys <- sort(names(children))
    for(child in keys) {
      cat('\t')
      c <- Element('child', list(ref=child))
      a <- children[[child]]
      parents <- a[order(unlist(lapply(a, function(x) suppressWarnings(as.numeric(paste(x[[1]],'.',x[[2]], sep=""))) )))]
      for(v in parents) {
        p <- Element('parent', list(
          ref=v[[1]],
          `edge-label`=v[[2]]
        ))
        c <- AddChild(c, p)
      }
      cat(paste(capture.output(WriteElement(c, level=1))), sep="\n")
      cat('\n')
    }
  }

  # Close tag
  cat('</adag>\n')

  if(is.character(out)) {
    sink()
  }
}

# ###############################
# Add-in functions for R
# ###############################

#' @rdname AddInvoke
#' @method AddInvoke ADAG
#' @seealso \code{\link{ADAG}}
#' @export
AddInvoke.ADAG <- function(obj, invoke) {
  obj$invoke.mixin <- AddInvokeMixin(obj$invoke.mixin, invoke)
  return(obj)
}

#' @rdname Metadata
#' @method Metadata ADAG
#' @seealso \code{\link{ADAG}}
#' @export
Metadata.ADAG <- function(obj, key, value) {
  obj$metadata.mixin <- AddMetadataDeclarative(obj$metadata.mixin, key, value)
  return(obj)
}
